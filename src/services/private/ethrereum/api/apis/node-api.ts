/* tslint:disable */
/* eslint-disable */
/**
 * Eth Beacon Node API
 * API specification for the beacon node, which enables users to query and participate in Ethereum 2.0 phase 0 beacon chain.  All requests by default send and receive JSON, and as such should have either or both of the \"Content-Type: application/json\" and \"Accept: application/json\" headers.  In addition, some requests can return data in the SSZ format.  To indicate that SSZ data is required in response to a request the header \"Accept: application/octet-stream\" should be sent.  Note that only a subset of requests can respond with data in SSZ format; these are noted in each individual request.  API endpoints are individually versioned.  As such, there is no direct relationship between all v1 endpoints, all v2 endpoints, _etc._ and no such relationship should be inferred.  All JSON responses return the requested data under a `data` key in the top level of their response.  Additional metadata may or may not be present in other keys at the top level of the response, dependent on the endpoint.  The rules that require an increase in version number are as follows:    - no field that is listed in an endpoint shall be removed without an increase in the version number   - no field that is listed in an endpoint shall be altered in terms of format (_e.g._ from a string to an array) without an     increase in the version number  Note that it is possible for a field to be added to an endpoint's data or metadata without an increase in the version number. 
 *
 * OpenAPI spec version: v2.5.0 - Ethereum Proof-of-Stake Consensus Specification v1.4.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { GetNetworkIdentityResponse } from '../models';
import { GetPeerCountResponse } from '../models';
import { GetPeerResponse } from '../models';
import { GetPeersResponse } from '../models';
import { GetSyncingStatusResponse } from '../models';
import { GetVersionResponse } from '../models';
import { InlineResponse404 } from '../models';
/**
 * NodeApi - axios parameter creator
 * @export
 */
export const NodeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns node health status in http status codes. Useful for load balancers.
         * @summary Get health check
         * @param {any} [syncingStatus] Customize syncing status instead of default status code (206)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: async (syncingStatus?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eth/v1/node/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (syncingStatus !== undefined) {
                localVarQueryParameter['syncing_status'] = syncingStatus;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves data about the node's network presence
         * @summary Get node network identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eth/v1/node/identity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests that the beacon node identify information about its implementation in a format similar to a  [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) field.
         * @summary Get version string of the running beacon node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eth/v1/node/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves data about the given peer
         * @summary Get peer
         * @param {any} peerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeer: async (peerId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'peerId' is not null or undefined
            if (peerId === null || peerId === undefined) {
                throw new RequiredError('peerId','Required parameter peerId was null or undefined when calling getPeer.');
            }
            const localVarPath = `/eth/v1/node/peers/{peer_id}`
                .replace(`{${"peer_id"}}`, encodeURIComponent(String(peerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves number of known peers.
         * @summary Get peer count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeerCount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eth/v1/node/peer_count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions
         * @summary Get node network peers
         * @param {any} [state] 
         * @param {any} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeers: async (state?: any, direction?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eth/v1/node/peers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to.
         * @summary Get node syncing status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncingStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eth/v1/node/syncing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodeApi - functional programming interface
 * @export
 */
export const NodeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns node health status in http status codes. Useful for load balancers.
         * @summary Get health check
         * @param {any} [syncingStatus] Customize syncing status instead of default status code (206)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealth(syncingStatus?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await NodeApiAxiosParamCreator(configuration).getHealth(syncingStatus, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves data about the node's network presence
         * @summary Get node network identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkIdentity(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetNetworkIdentityResponse>>> {
            const localVarAxiosArgs = await NodeApiAxiosParamCreator(configuration).getNetworkIdentity(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requests that the beacon node identify information about its implementation in a format similar to a  [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) field.
         * @summary Get version string of the running beacon node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetVersionResponse>>> {
            const localVarAxiosArgs = await NodeApiAxiosParamCreator(configuration).getNodeVersion(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves data about the given peer
         * @summary Get peer
         * @param {any} peerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeer(peerId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetPeerResponse>>> {
            const localVarAxiosArgs = await NodeApiAxiosParamCreator(configuration).getPeer(peerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves number of known peers.
         * @summary Get peer count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeerCount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetPeerCountResponse>>> {
            const localVarAxiosArgs = await NodeApiAxiosParamCreator(configuration).getPeerCount(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions
         * @summary Get node network peers
         * @param {any} [state] 
         * @param {any} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeers(state?: any, direction?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetPeersResponse>>> {
            const localVarAxiosArgs = await NodeApiAxiosParamCreator(configuration).getPeers(state, direction, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to.
         * @summary Get node syncing status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSyncingStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetSyncingStatusResponse>>> {
            const localVarAxiosArgs = await NodeApiAxiosParamCreator(configuration).getSyncingStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NodeApi - factory interface
 * @export
 */
export const NodeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns node health status in http status codes. Useful for load balancers.
         * @summary Get health check
         * @param {any} [syncingStatus] Customize syncing status instead of default status code (206)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealth(syncingStatus?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return NodeApiFp(configuration).getHealth(syncingStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves data about the node's network presence
         * @summary Get node network identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkIdentity(options?: AxiosRequestConfig): Promise<AxiosResponse<GetNetworkIdentityResponse>> {
            return NodeApiFp(configuration).getNetworkIdentity(options).then((request) => request(axios, basePath));
        },
        /**
         * Requests that the beacon node identify information about its implementation in a format similar to a  [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) field.
         * @summary Get version string of the running beacon node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeVersion(options?: AxiosRequestConfig): Promise<AxiosResponse<GetVersionResponse>> {
            return NodeApiFp(configuration).getNodeVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves data about the given peer
         * @summary Get peer
         * @param {any} peerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeer(peerId: any, options?: AxiosRequestConfig): Promise<AxiosResponse<GetPeerResponse>> {
            return NodeApiFp(configuration).getPeer(peerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves number of known peers.
         * @summary Get peer count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeerCount(options?: AxiosRequestConfig): Promise<AxiosResponse<GetPeerCountResponse>> {
            return NodeApiFp(configuration).getPeerCount(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions
         * @summary Get node network peers
         * @param {any} [state] 
         * @param {any} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeers(state?: any, direction?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<GetPeersResponse>> {
            return NodeApiFp(configuration).getPeers(state, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to.
         * @summary Get node syncing status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSyncingStatus(options?: AxiosRequestConfig): Promise<AxiosResponse<GetSyncingStatusResponse>> {
            return NodeApiFp(configuration).getSyncingStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodeApi - object-oriented interface
 * @export
 * @class NodeApi
 * @extends {BaseAPI}
 */
export class NodeApi extends BaseAPI {
    /**
     * Returns node health status in http status codes. Useful for load balancers.
     * @summary Get health check
     * @param {any} [syncingStatus] Customize syncing status instead of default status code (206)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public async getHealth(syncingStatus?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return NodeApiFp(this.configuration).getHealth(syncingStatus, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves data about the node's network presence
     * @summary Get node network identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public async getNetworkIdentity(options?: AxiosRequestConfig) : Promise<AxiosResponse<GetNetworkIdentityResponse>> {
        return NodeApiFp(this.configuration).getNetworkIdentity(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests that the beacon node identify information about its implementation in a format similar to a  [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) field.
     * @summary Get version string of the running beacon node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public async getNodeVersion(options?: AxiosRequestConfig) : Promise<AxiosResponse<GetVersionResponse>> {
        return NodeApiFp(this.configuration).getNodeVersion(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves data about the given peer
     * @summary Get peer
     * @param {any} peerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public async getPeer(peerId: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetPeerResponse>> {
        return NodeApiFp(this.configuration).getPeer(peerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves number of known peers.
     * @summary Get peer count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public async getPeerCount(options?: AxiosRequestConfig) : Promise<AxiosResponse<GetPeerCountResponse>> {
        return NodeApiFp(this.configuration).getPeerCount(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions
     * @summary Get node network peers
     * @param {any} [state] 
     * @param {any} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public async getPeers(state?: any, direction?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetPeersResponse>> {
        return NodeApiFp(this.configuration).getPeers(state, direction, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to.
     * @summary Get node syncing status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public async getSyncingStatus(options?: AxiosRequestConfig) : Promise<AxiosResponse<GetSyncingStatusResponse>> {
        return NodeApiFp(this.configuration).getSyncingStatus(options).then((request) => request(this.axios, this.basePath));
    }
}
