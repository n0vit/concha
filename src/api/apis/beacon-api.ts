/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * Eth Beacon Node API
 * API specification for the beacon node, which enables users to query and participate in Ethereum 2.0 phase 0 beacon chain.  All requests by default send and receive JSON, and as such should have either or both of the \"Content-Type: application/json\" and \"Accept: application/json\" headers.  In addition, some requests can return data in the SSZ format.  To indicate that SSZ data is required in response to a request the header \"Accept: application/octet-stream\" should be sent.  Note that only a subset of requests can respond with data in SSZ format; these are noted in each individual request.  API endpoints are individually versioned.  As such, there is no direct relationship between all v1 endpoints, all v2 endpoints, _etc._ and no such relationship should be inferred.  All JSON responses return the requested data under a `data` key in the top level of their response.  Additional metadata may or may not be present in other keys at the top level of the response, dependent on the endpoint.  The rules that require an increase in version number are as follows:    - no field that is listed in an endpoint shall be removed without an increase in the version number   - no field that is listed in an endpoint shall be altered in terms of format (_e.g._ from a string to an array) without an     increase in the version number  Note that it is possible for a field to be added to an endpoint's data or metadata without an increase in the version number.
 *
 * OpenAPI spec version: v2.5.0 - Ethereum Proof-of-Stake Consensus Specification v1.4.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosResponse,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, RequestArgs, BaseAPI, RequiredError } from "../base";
import { GetAttestationsRewardsResponse } from "../models";
import { GetBlindedBlockResponse } from "../models";
import { GetBlobSidecarsResponse } from "../models";
import { GetBlockAttestationsResponse } from "../models";
import { GetBlockHeaderResponse } from "../models";
import { GetBlockHeadersResponse } from "../models";
import { GetBlockRewardsResponse } from "../models";
import { GetBlockRootResponse } from "../models";
import { GetBlockV2Response } from "../models";
import { GetDepositSnapshotResponse } from "../models";
import { GetEpochCommitteesResponse } from "../models";
import { GetEpochSyncCommitteesResponse } from "../models";
import { GetGenesisResponse } from "../models";
import { GetLightClientBootstrapResponse } from "../models";
import { GetLightClientFinalityUpdateResponse } from "../models";
import { GetLightClientOptimisticUpdateResponse } from "../models";
import { GetPoolAttestationsResponse } from "../models";
import { GetPoolAttesterSlashingsResponse } from "../models";
import { GetPoolBLSToExecutionChangesResponse } from "../models";
import { GetPoolProposerSlashingsResponse } from "../models";
import { GetPoolVoluntaryExitsResponse } from "../models";
import { GetStateFinalityCheckpointsResponse } from "../models";
import { GetStateForkResponse } from "../models";
import { GetStateRandaoResponse } from "../models";
import { GetStateRootResponse } from "../models";
import { GetStateValidatorBalancesResponse } from "../models";
import { GetStateValidatorResponse } from "../models";
import { GetStateValidatorsResponse } from "../models";
import { GetSyncCommitteeRewardsResponse } from "../models";
import { PoolAttesterSlashingsBody } from "../models";
import { PoolProposerSlashingsBody } from "../models";
import { PoolVoluntaryExitsBody } from "../models";
import { StateIdValidatorsBody } from "../models";
/**
 * BeaconApi - axios parameter creator
 * @export
 */

globalAxios.defaults.timeout = 60000;
export const BeaconApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve attestation reward info for validators specified by array of public keys or validator index. If no array is provided, return reward info for every validator.
     * @summary Get attestations rewards
     * @param {any} epoch The epoch to get rewards info from
     * @param {any} [body] An array of either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttestationsRewards: async (
      epoch: any,
      body?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'epoch' is not null or undefined
      if (epoch === null || epoch === undefined) {
        throw new RequiredError(
          "epoch",
          "Required parameter epoch was null or undefined when calling getAttestationsRewards."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/rewards/attestations/{epoch}`.replace(
          `{${"epoch"}}`,
          encodeURIComponent(String(epoch))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves blinded block for given block ID. Depending on `Accept` header it can be returned either as JSON or as bytes serialized by SSZ
     * @summary Get blinded block
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlindedBlock: async (
      blockId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      if (blockId === null || blockId === undefined) {
        throw new RequiredError(
          "blockId",
          "Required parameter blockId was null or undefined when calling getBlindedBlock."
        );
      }
      const localVarPath = `/eth/v1/beacon/blinded_blocks/{block_id}`.replace(
        `{${"block_id"}}`,
        encodeURIComponent(String(blockId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves blob sidecars for a given block id. Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.  If the `indices` parameter is specified, only the blob sidecars with the specified indices will be returned. There are no guarantees for the returned blob sidecars in terms of ordering.
     * @summary Get blob sidecars
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {any} [indices] Array of indices for blob sidecars to request for in the specified block. Returns all blob sidecars in the block if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlobSidecars: async (
      blockId: any,
      indices?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      if (blockId === null || blockId === undefined) {
        throw new RequiredError(
          "blockId",
          "Required parameter blockId was null or undefined when calling getBlobSidecars."
        );
      }
      const localVarPath = `/eth/v1/beacon/blob_sidecars/{block_id}`.replace(
        `{${"block_id"}}`,
        encodeURIComponent(String(blockId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (indices !== undefined) {
        localVarQueryParameter["indices"] = indices;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves attestation included in requested block.
     * @summary Get block attestations
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockAttestations: async (
      blockId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      if (blockId === null || blockId === undefined) {
        throw new RequiredError(
          "blockId",
          "Required parameter blockId was null or undefined when calling getBlockAttestations."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/blocks/{block_id}/attestations`.replace(
          `{${"block_id"}}`,
          encodeURIComponent(String(blockId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves block header for given block id.
     * @summary Get block header
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockHeader: async (
      blockId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      if (blockId === null || blockId === undefined) {
        throw new RequiredError(
          "blockId",
          "Required parameter blockId was null or undefined when calling getBlockHeader."
        );
      }
      const localVarPath = `/eth/v1/beacon/headers/{block_id}`.replace(
        `{${"block_id"}}`,
        encodeURIComponent(String(blockId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves block headers matching given query. By default it will fetch current head slot blocks.
     * @summary Get block headers
     * @param {any} [slot]
     * @param {any} [parentRoot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockHeaders: async (
      slot?: any,
      parentRoot?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/beacon/headers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (slot !== undefined) {
        localVarQueryParameter["slot"] = slot;
      }

      if (parentRoot !== undefined) {
        localVarQueryParameter["parent_root"] = parentRoot;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve block reward info for a single block
     * @summary Get block rewards
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockRewards: async (
      blockId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      if (blockId === null || blockId === undefined) {
        throw new RequiredError(
          "blockId",
          "Required parameter blockId was null or undefined when calling getBlockRewards."
        );
      }
      const localVarPath = `/eth/v1/beacon/rewards/blocks/{block_id}`.replace(
        `{${"block_id"}}`,
        encodeURIComponent(String(blockId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader
     * @summary Get block root
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockRoot: async (
      blockId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      if (blockId === null || blockId === undefined) {
        throw new RequiredError(
          "blockId",
          "Required parameter blockId was null or undefined when calling getBlockRoot."
        );
      }
      const localVarPath = `/eth/v1/beacon/blocks/{block_id}/root`.replace(
        `{${"block_id"}}`,
        encodeURIComponent(String(blockId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves block details for given block id. Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ
     * @summary Get block
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlockV2: async (
      blockId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      if (blockId === null || blockId === undefined) {
        throw new RequiredError(
          "blockId",
          "Required parameter blockId was null or undefined when calling getBlockV2."
        );
      }
      const localVarPath = `/eth/v2/beacon/blocks/{block_id}`.replace(
        `{${"block_id"}}`,
        encodeURIComponent(String(blockId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve [EIP-4881](https://eips.ethereum.org/EIPS/eip-4881) Deposit Tree Snapshot. Depending on `Accept` header it can be returned either as json or as bytes serialzed by SSZ
     * @summary Get Deposit Tree Snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDepositSnapshot: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/beacon/deposit_snapshot`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the committees for the given state.
     * @summary Get all committees for a state.
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [epoch] Fetch committees for the given epoch.  If not present then the committees for the epoch of the state will be obtained.
     * @param {any} [index] Restrict returned values to those matching the supplied committee index.
     * @param {any} [slot] Restrict returned values to those matching the supplied slot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEpochCommittees: async (
      stateId: any,
      epoch?: any,
      index?: any,
      slot?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling getEpochCommittees."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/states/{state_id}/committees`.replace(
          `{${"state_id"}}`,
          encodeURIComponent(String(stateId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (epoch !== undefined) {
        localVarQueryParameter["epoch"] = epoch;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (slot !== undefined) {
        localVarQueryParameter["slot"] = slot;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the current sync committee for the given state. Also returns the subcommittee assignments.
     * @summary Get sync committees for a state.
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [epoch] Fetch sync committees for the given epoch.  If not present then the sync committees for the epoch of the state will be obtained.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEpochSyncCommittees: async (
      stateId: any,
      epoch?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling getEpochSyncCommittees."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/states/{state_id}/sync_committees`.replace(
          `{${"state_id"}}`,
          encodeURIComponent(String(stateId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (epoch !== undefined) {
        localVarQueryParameter["epoch"] = epoch;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve details of the chain's genesis which can be used to identify chain.
     * @summary Retrieve details of the chain's genesis.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGenesis: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/beacon/genesis`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests the [`LightClientBootstrap`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientbootstrap) structure corresponding to a given post-Altair beacon block root. Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_bootstrap`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_bootstrap). To fulfill a request, the requested block's post state needs to be known.
     * @summary Get `LightClientBootstrap` structure for a requested block root
     * @param {any} blockRoot Block root. \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLightClientBootstrap: async (
      blockRoot: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockRoot' is not null or undefined
      if (blockRoot === null || blockRoot === undefined) {
        throw new RequiredError(
          "blockRoot",
          "Required parameter blockRoot was null or undefined when calling getLightClientBootstrap."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/light_client/bootstrap/{block_root}`.replace(
          `{${"block_root"}}`,
          encodeURIComponent(String(blockRoot))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests the latest [`LightClientFinalityUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientfinalityupdate) known by the server. Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_finality_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_finality_update).
     * @summary Get the latest known `LightClientFinalityUpdate`
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLightClientFinalityUpdate: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/beacon/light_client/finality_update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests the latest [`LightClientOptimisticUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientoptimisticupdate) known by the server. Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_optimistic_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_optimistic_update).
     * @summary Get the latest known `LightClientOptimisticUpdate`
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLightClientOptimisticUpdate: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/beacon/light_client/optimistic_update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests the [`LightClientUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientupdate) instances in the sync committee period range `[start_period, start_period + count)`, leading up to the current head sync committee period as selected by fork choice. Depending on the `Accept` header they can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_update). They MUST respond with at least the earliest known result within the requested range, and MUST send results in consecutive order (by period). The response MUST NOT contain more than [`min(MAX_REQUEST_LIGHT_CLIENT_UPDATES, count)`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/p2p-interface.md#configuration) results.
     * @summary Get `LightClientUpdate` instances in a requested sync committee period range
     * @param {any} startPeriod
     * @param {any} count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLightClientUpdatesByRange: async (
      startPeriod: any,
      count: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'startPeriod' is not null or undefined
      if (startPeriod === null || startPeriod === undefined) {
        throw new RequiredError(
          "startPeriod",
          "Required parameter startPeriod was null or undefined when calling getLightClientUpdatesByRange."
        );
      }
      // verify required parameter 'count' is not null or undefined
      if (count === null || count === undefined) {
        throw new RequiredError(
          "count",
          "Required parameter count was null or undefined when calling getLightClientUpdatesByRange."
        );
      }
      const localVarPath = `/eth/v1/beacon/light_client/updates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (startPeriod !== undefined) {
        localVarQueryParameter["start_period"] = startPeriod;
      }

      if (count !== undefined) {
        localVarQueryParameter["count"] = count;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves attestations known by the node but not necessarily incorporated into any block
     * @summary Get Attestations from operations pool
     * @param {any} [slot]
     * @param {any} [committeeIndex]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoolAttestations: async (
      slot?: any,
      committeeIndex?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/beacon/pool/attestations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (slot !== undefined) {
        localVarQueryParameter["slot"] = slot;
      }

      if (committeeIndex !== undefined) {
        localVarQueryParameter["committee_index"] = committeeIndex;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves attester slashings known by the node but not necessarily incorporated into any block
     * @summary Get AttesterSlashings from operations pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoolAttesterSlashings: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/beacon/pool/attester_slashings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves BLS to execution changes known by the node but not necessarily incorporated into any block
     * @summary Get SignedBLSToExecutionChange from operations pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoolBLSToExecutionChanges: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/beacon/pool/bls_to_execution_changes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves proposer slashings known by the node but not necessarily incorporated into any block
     * @summary Get ProposerSlashings from operations pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoolProposerSlashings: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/beacon/pool/proposer_slashings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves voluntary exits known by the node but not necessarily incorporated into any block
     * @summary Get SignedVoluntaryExit from operations pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoolVoluntaryExits: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/beacon/pool/voluntary_exits`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns finality checkpoints for state with given 'stateId'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root.
     * @summary Get state finality checkpoints
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStateFinalityCheckpoints: async (
      stateId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling getStateFinalityCheckpoints."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/states/{state_id}/finality_checkpoints`.replace(
          `{${"state_id"}}`,
          encodeURIComponent(String(stateId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#fork) object for state with given 'stateId'.
     * @summary Get Fork object for requested state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStateFork: async (
      stateId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling getStateFork."
        );
      }
      const localVarPath = `/eth/v1/beacon/states/{state_id}/fork`.replace(
        `{${"state_id"}}`,
        encodeURIComponent(String(stateId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch the RANDAO mix for the requested epoch from the state identified by `state_id`.  If an epoch is not specified then the RANDAO mix for the state's current epoch will be returned.  By adjusting the `state_id` parameter you can query for any historic value of the RANDAO mix. Ordinarily states from the same epoch will mutate the RANDAO mix for that epoch as blocks are applied.
     * @summary Get the RANDAO mix for some epoch in a specified state.
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [epoch] Epoch to fetch the RANDAO mix for. Default: state&#x27;s current epoch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStateRandao: async (
      stateId: any,
      epoch?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling getStateRandao."
        );
      }
      const localVarPath = `/eth/v1/beacon/states/{state_id}/randao`.replace(
        `{${"state_id"}}`,
        encodeURIComponent(String(stateId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (epoch !== undefined) {
        localVarQueryParameter["epoch"] = epoch;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Calculates HashTreeRoot for state with given 'stateId'. If stateId is root, same value will be returned.
     * @summary Get state SSZ HashTreeRoot
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStateRoot: async (
      stateId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling getStateRoot."
        );
      }
      const localVarPath = `/eth/v1/beacon/states/{state_id}/root`.replace(
        `{${"state_id"}}`,
        encodeURIComponent(String(stateId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns validator specified by state and id or public key along with status and balance.
     * @summary Get validator from state by id
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} validatorId Either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStateValidator: async (
      stateId: any,
      validatorId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling getStateValidator."
        );
      }
      // verify required parameter 'validatorId' is not null or undefined
      if (validatorId === null || validatorId === undefined) {
        throw new RequiredError(
          "validatorId",
          "Required parameter validatorId was null or undefined when calling getStateValidator."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/states/{state_id}/validators/{validator_id}`
          .replace(`{${"state_id"}}`, encodeURIComponent(String(stateId)))
          .replace(
            `{${"validator_id"}}`,
            encodeURIComponent(String(validatorId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns filterable list of validators balances.  Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index is returned for each balance, and can be used to confirm for which inputs a response has been returned.
     * @summary Get validator balances from state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [id] Either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStateValidatorBalances: async (
      stateId: any,
      id?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling getStateValidatorBalances."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/states/{state_id}/validator_balances`.replace(
          `{${"state_id"}}`,
          encodeURIComponent(String(stateId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns filterable list of validators with their balance, status and index.  Information will be returned for all indices or public key that match known validators.  If an index or public key does not match any known validator, no information will be returned but this will not cause an error.  There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned.
     * @summary Get validators from state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [id] Either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {any} [status] [Validator status specification](https://hackmd.io/ofFJ5gOmQpu1jjHilHbdQQ)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStateValidators: async (
      stateId: any,
      id?: any,
      status?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling getStateValidators."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/states/{state_id}/validators`.replace(
          `{${"state_id"}}`,
          encodeURIComponent(String(stateId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves rewards info for sync committee members specified by array of public keys or validator index. If no array is provided, return reward info for every committee member.
     * @summary Get sync committee rewards
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {any} [body] An array of either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSyncCommitteeRewards: async (
      blockId: any,
      body?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'blockId' is not null or undefined
      if (blockId === null || blockId === undefined) {
        throw new RequiredError(
          "blockId",
          "Required parameter blockId was null or undefined when calling getSyncCommitteeRewards."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/rewards/sync_committee/{block_id}`.replace(
          `{${"block_id"}}`,
          encodeURIComponent(String(blockId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns filterable list of validators balances.  Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index is returned for each balance, and can be used to confirm for which inputs a response has been returned.
     * @summary Get validator balances from state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [body] An array of either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postStateValidatorBalances: async (
      stateId: any,
      body?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling postStateValidatorBalances."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/states/{state_id}/validator_balances`.replace(
          `{${"state_id"}}`,
          encodeURIComponent(String(stateId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns filterable list of validators with their balance, status and index.  Information will be returned for all indices or public key that match known validators.  If an index or public key does not match any known validator, no information will be returned but this will not cause an error.  There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned.  The POST variant of this endpoint has the same semantics as the GET endpoint but passes the lists of IDs and statuses via a POST body in order to enable larger requests.
     * @summary Get validators from state
     * @param {StateIdValidatorsBody} body The lists of validator IDs and statuses to filter on. Either or both may be &#x60;null&#x60; to signal that no filtering on that attribute is desired.
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postStateValidators: async (
      body: StateIdValidatorsBody,
      stateId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling postStateValidators."
        );
      }
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling postStateValidators."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/states/{state_id}/validators`.replace(
          `{${"state_id"}}`,
          encodeURIComponent(String(stateId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlindedBlock: async (
      body: any,
      ethConsensusVersion?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlindedBlock."
        );
      }
      const localVarPath = `/eth/v1/beacon/blinded_blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlindedBlock: async (
      body: any,
      ethConsensusVersion?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlindedBlock."
        );
      }
      const localVarPath = `/eth/v1/beacon/blinded_blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlindedBlockV2: async (
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlindedBlockV2."
        );
      }
      // verify required parameter 'ethConsensusVersion' is not null or undefined
      if (ethConsensusVersion === null || ethConsensusVersion === undefined) {
        throw new RequiredError(
          "ethConsensusVersion",
          "Required parameter ethConsensusVersion was null or undefined when calling publishBlindedBlockV2."
        );
      }
      const localVarPath = `/eth/v2/beacon/blinded_blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (broadcastValidation !== undefined) {
        localVarQueryParameter["broadcast_validation"] = broadcastValidation;
      }

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlindedBlockV2: async (
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlindedBlockV2."
        );
      }
      // verify required parameter 'ethConsensusVersion' is not null or undefined
      if (ethConsensusVersion === null || ethConsensusVersion === undefined) {
        throw new RequiredError(
          "ethConsensusVersion",
          "Required parameter ethConsensusVersion was null or undefined when calling publishBlindedBlockV2."
        );
      }
      const localVarPath = `/eth/v2/beacon/blinded_blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (broadcastValidation !== undefined) {
        localVarQueryParameter["broadcast_validation"] = broadcastValidation;
      }

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlock: async (
      body: any,
      ethConsensusVersion?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlock."
        );
      }
      const localVarPath = `/eth/v1/beacon/blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlock: async (
      body: any,
      ethConsensusVersion?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlock."
        );
      }
      const localVarPath = `/eth/v1/beacon/blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlockV2: async (
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlockV2."
        );
      }
      // verify required parameter 'ethConsensusVersion' is not null or undefined
      if (ethConsensusVersion === null || ethConsensusVersion === undefined) {
        throw new RequiredError(
          "ethConsensusVersion",
          "Required parameter ethConsensusVersion was null or undefined when calling publishBlockV2."
        );
      }
      const localVarPath = `/eth/v2/beacon/blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (broadcastValidation !== undefined) {
        localVarQueryParameter["broadcast_validation"] = broadcastValidation;
      }

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlockV2: async (
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlockV2."
        );
      }
      // verify required parameter 'ethConsensusVersion' is not null or undefined
      if (ethConsensusVersion === null || ethConsensusVersion === undefined) {
        throw new RequiredError(
          "ethConsensusVersion",
          "Required parameter ethConsensusVersion was null or undefined when calling publishBlockV2."
        );
      }
      const localVarPath = `/eth/v2/beacon/blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (broadcastValidation !== undefined) {
        localVarQueryParameter["broadcast_validation"] = broadcastValidation;
      }

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Submits Attestation objects to the node.  Each attestation in the request body is processed individually.  If an attestation is validated successfully the node MUST publish that attestation on the appropriate subnet.  If one or more attestations fail validation the node MUST return a 400 error with details of which attestations have failed, and why.
     * @summary Submit Attestation objects to node
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitPoolAttestations: async (
      body: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling submitPoolAttestations."
        );
      }
      const localVarPath = `/eth/v1/beacon/pool/attestations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Submits AttesterSlashing object to node's pool and if passes validation node MUST broadcast it to network.
     * @summary Submit AttesterSlashing object to node's pool
     * @param {PoolAttesterSlashingsBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitPoolAttesterSlashings: async (
      body: PoolAttesterSlashingsBody,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling submitPoolAttesterSlashings."
        );
      }
      const localVarPath = `/eth/v1/beacon/pool/attester_slashings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Submits a list of SignedBLSToExecutionChange objects to node's pool. Any that pass validation MUST be broadcast to the network.
     * @summary Submit SignedBLSToExecutionChange object to node's pool
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitPoolBLSToExecutionChange: async (
      body: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling submitPoolBLSToExecutionChange."
        );
      }
      const localVarPath = `/eth/v1/beacon/pool/bls_to_execution_changes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Submits ProposerSlashing object to node's pool and if passes validation  node MUST broadcast it to network.
     * @summary Submit ProposerSlashing object to node's pool
     * @param {PoolProposerSlashingsBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitPoolProposerSlashings: async (
      body: PoolProposerSlashingsBody,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling submitPoolProposerSlashings."
        );
      }
      const localVarPath = `/eth/v1/beacon/pool/proposer_slashings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Submits sync committee signature objects to the node.  Sync committee signatures are not present in phase0, but are required for Altair networks.  If a sync committee signature is validated successfully the node MUST publish that sync committee signature on all applicable subnets.  If one or more sync committee signatures fail validation the node MUST return a 400 error with details of which sync committee signatures have failed, and why.
     * @summary Submit sync committee signatures to node
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitPoolSyncCommitteeSignatures: async (
      body: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling submitPoolSyncCommitteeSignatures."
        );
      }
      const localVarPath = `/eth/v1/beacon/pool/sync_committees`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Submits SignedVoluntaryExit object to node's pool and if passes validation node MUST broadcast it to network.
     * @summary Submit SignedVoluntaryExit object to node's pool
     * @param {PoolVoluntaryExitsBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitPoolVoluntaryExit: async (
      body: PoolVoluntaryExitsBody,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling submitPoolVoluntaryExit."
        );
      }
      const localVarPath = `/eth/v1/beacon/pool/voluntary_exits`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BeaconApi - functional programming interface
 * @export
 */
export const BeaconApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Retrieve attestation reward info for validators specified by array of public keys or validator index. If no array is provided, return reward info for every validator.
     * @summary Get attestations rewards
     * @param {any} epoch The epoch to get rewards info from
     * @param {any} [body] An array of either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAttestationsRewards(
      epoch: any,
      body?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetAttestationsRewardsResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getAttestationsRewards(epoch, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves blinded block for given block ID. Depending on `Accept` header it can be returned either as JSON or as bytes serialized by SSZ
     * @summary Get blinded block
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlindedBlock(
      blockId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetBlindedBlockResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getBlindedBlock(blockId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves blob sidecars for a given block id. Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.  If the `indices` parameter is specified, only the blob sidecars with the specified indices will be returned. There are no guarantees for the returned blob sidecars in terms of ordering.
     * @summary Get blob sidecars
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {any} [indices] Array of indices for blob sidecars to request for in the specified block. Returns all blob sidecars in the block if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlobSidecars(
      blockId: any,
      indices?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetBlobSidecarsResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getBlobSidecars(blockId, indices, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves attestation included in requested block.
     * @summary Get block attestations
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockAttestations(
      blockId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetBlockAttestationsResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getBlockAttestations(blockId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves block header for given block id.
     * @summary Get block header
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockHeader(
      blockId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetBlockHeaderResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getBlockHeader(blockId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves block headers matching given query. By default it will fetch current head slot blocks.
     * @summary Get block headers
     * @param {any} [slot]
     * @param {any} [parentRoot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockHeaders(
      slot?: any,
      parentRoot?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetBlockHeadersResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getBlockHeaders(slot, parentRoot, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieve block reward info for a single block
     * @summary Get block rewards
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockRewards(
      blockId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetBlockRewardsResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getBlockRewards(blockId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader
     * @summary Get block root
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockRoot(
      blockId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetBlockRootResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getBlockRoot(blockId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves block details for given block id. Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ
     * @summary Get block
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockV2(
      blockId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetBlockV2Response>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getBlockV2(blockId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieve [EIP-4881](https://eips.ethereum.org/EIPS/eip-4881) Deposit Tree Snapshot. Depending on `Accept` header it can be returned either as json or as bytes serialzed by SSZ
     * @summary Get Deposit Tree Snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDepositSnapshot(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetDepositSnapshotResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getDepositSnapshot(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves the committees for the given state.
     * @summary Get all committees for a state.
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [epoch] Fetch committees for the given epoch.  If not present then the committees for the epoch of the state will be obtained.
     * @param {any} [index] Restrict returned values to those matching the supplied committee index.
     * @param {any} [slot] Restrict returned values to those matching the supplied slot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEpochCommittees(
      stateId: any,
      epoch?: any,
      index?: any,
      slot?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetEpochCommitteesResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getEpochCommittees(stateId, epoch, index, slot, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves the current sync committee for the given state. Also returns the subcommittee assignments.
     * @summary Get sync committees for a state.
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [epoch] Fetch sync committees for the given epoch.  If not present then the sync committees for the epoch of the state will be obtained.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEpochSyncCommittees(
      stateId: any,
      epoch?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetEpochSyncCommitteesResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getEpochSyncCommittees(stateId, epoch, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieve details of the chain's genesis which can be used to identify chain.
     * @summary Retrieve details of the chain's genesis.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGenesis(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetGenesisResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getGenesis(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Requests the [`LightClientBootstrap`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientbootstrap) structure corresponding to a given post-Altair beacon block root. Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_bootstrap`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_bootstrap). To fulfill a request, the requested block's post state needs to be known.
     * @summary Get `LightClientBootstrap` structure for a requested block root
     * @param {any} blockRoot Block root. \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLightClientBootstrap(
      blockRoot: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetLightClientBootstrapResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getLightClientBootstrap(blockRoot, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Requests the latest [`LightClientFinalityUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientfinalityupdate) known by the server. Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_finality_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_finality_update).
     * @summary Get the latest known `LightClientFinalityUpdate`
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLightClientFinalityUpdate(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetLightClientFinalityUpdateResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getLightClientFinalityUpdate(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Requests the latest [`LightClientOptimisticUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientoptimisticupdate) known by the server. Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_optimistic_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_optimistic_update).
     * @summary Get the latest known `LightClientOptimisticUpdate`
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLightClientOptimisticUpdate(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetLightClientOptimisticUpdateResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getLightClientOptimisticUpdate(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Requests the [`LightClientUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientupdate) instances in the sync committee period range `[start_period, start_period + count)`, leading up to the current head sync committee period as selected by fork choice. Depending on the `Accept` header they can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_update). They MUST respond with at least the earliest known result within the requested range, and MUST send results in consecutive order (by period). The response MUST NOT contain more than [`min(MAX_REQUEST_LIGHT_CLIENT_UPDATES, count)`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/p2p-interface.md#configuration) results.
     * @summary Get `LightClientUpdate` instances in a requested sync committee period range
     * @param {any} startPeriod
     * @param {any} count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLightClientUpdatesByRange(
      startPeriod: any,
      count: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getLightClientUpdatesByRange(startPeriod, count, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves attestations known by the node but not necessarily incorporated into any block
     * @summary Get Attestations from operations pool
     * @param {any} [slot]
     * @param {any} [committeeIndex]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoolAttestations(
      slot?: any,
      committeeIndex?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetPoolAttestationsResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getPoolAttestations(slot, committeeIndex, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves attester slashings known by the node but not necessarily incorporated into any block
     * @summary Get AttesterSlashings from operations pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoolAttesterSlashings(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetPoolAttesterSlashingsResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getPoolAttesterSlashings(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves BLS to execution changes known by the node but not necessarily incorporated into any block
     * @summary Get SignedBLSToExecutionChange from operations pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoolBLSToExecutionChanges(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetPoolBLSToExecutionChangesResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getPoolBLSToExecutionChanges(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves proposer slashings known by the node but not necessarily incorporated into any block
     * @summary Get ProposerSlashings from operations pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoolProposerSlashings(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetPoolProposerSlashingsResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getPoolProposerSlashings(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves voluntary exits known by the node but not necessarily incorporated into any block
     * @summary Get SignedVoluntaryExit from operations pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoolVoluntaryExits(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetPoolVoluntaryExitsResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getPoolVoluntaryExits(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns finality checkpoints for state with given 'stateId'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root.
     * @summary Get state finality checkpoints
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateFinalityCheckpoints(
      stateId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetStateFinalityCheckpointsResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getStateFinalityCheckpoints(stateId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#fork) object for state with given 'stateId'.
     * @summary Get Fork object for requested state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateFork(
      stateId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetStateForkResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getStateFork(stateId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Fetch the RANDAO mix for the requested epoch from the state identified by `state_id`.  If an epoch is not specified then the RANDAO mix for the state's current epoch will be returned.  By adjusting the `state_id` parameter you can query for any historic value of the RANDAO mix. Ordinarily states from the same epoch will mutate the RANDAO mix for that epoch as blocks are applied.
     * @summary Get the RANDAO mix for some epoch in a specified state.
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [epoch] Epoch to fetch the RANDAO mix for. Default: state&#x27;s current epoch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateRandao(
      stateId: any,
      epoch?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetStateRandaoResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getStateRandao(stateId, epoch, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Calculates HashTreeRoot for state with given 'stateId'. If stateId is root, same value will be returned.
     * @summary Get state SSZ HashTreeRoot
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateRoot(
      stateId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetStateRootResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getStateRoot(stateId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns validator specified by state and id or public key along with status and balance.
     * @summary Get validator from state by id
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} validatorId Either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateValidator(
      stateId: any,
      validatorId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetStateValidatorResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getStateValidator(stateId, validatorId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns filterable list of validators balances.  Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index is returned for each balance, and can be used to confirm for which inputs a response has been returned.
     * @summary Get validator balances from state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [id] Either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateValidatorBalances(
      stateId: any,
      id?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetStateValidatorBalancesResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getStateValidatorBalances(stateId, id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns filterable list of validators with their balance, status and index.  Information will be returned for all indices or public key that match known validators.  If an index or public key does not match any known validator, no information will be returned but this will not cause an error.  There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned.
     * @summary Get validators from state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [id] Either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {any} [status] [Validator status specification](https://hackmd.io/ofFJ5gOmQpu1jjHilHbdQQ)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateValidators(
      stateId: any,
      id?: any,
      status?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetStateValidatorsResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getStateValidators(stateId, id, status, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves rewards info for sync committee members specified by array of public keys or validator index. If no array is provided, return reward info for every committee member.
     * @summary Get sync committee rewards
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {any} [body] An array of either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSyncCommitteeRewards(
      blockId: any,
      body?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetSyncCommitteeRewardsResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).getSyncCommitteeRewards(blockId, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns filterable list of validators balances.  Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index is returned for each balance, and can be used to confirm for which inputs a response has been returned.
     * @summary Get validator balances from state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [body] An array of either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postStateValidatorBalances(
      stateId: any,
      body?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetStateValidatorBalancesResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).postStateValidatorBalances(stateId, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns filterable list of validators with their balance, status and index.  Information will be returned for all indices or public key that match known validators.  If an index or public key does not match any known validator, no information will be returned but this will not cause an error.  There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned.  The POST variant of this endpoint has the same semantics as the GET endpoint but passes the lists of IDs and statuses via a POST body in order to enable larger requests.
     * @summary Get validators from state
     * @param {StateIdValidatorsBody} body The lists of validator IDs and statuses to filter on. Either or both may be &#x60;null&#x60; to signal that no filtering on that attribute is desired.
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postStateValidators(
      body: StateIdValidatorsBody,
      stateId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetStateValidatorsResponse>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).postStateValidators(body, stateId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlindedBlock(
      body: any,
      ethConsensusVersion?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).publishBlindedBlock(body, ethConsensusVersion, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    // async publishBlindedBlock(
    //   body: any,
    //   ethConsensusVersion?: any,
    //   options?: AxiosRequestConfig
    // ): Promise<
    //   (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    // > {
    //   const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
    //     configuration
    //   ).publishBlindedBlock(body, ethConsensusVersion, options);
    //   return (
    //     axios: AxiosInstance = globalAxios,
    //     basePath: string = BASE_PATH
    //   ) => {
    //     const axiosRequestArgs: AxiosRequestConfig = {
    //       ...localVarAxiosArgs.options,
    //       url: basePath + localVarAxiosArgs.url,
    //     };
    //     return axios.request(axiosRequestArgs);
    //   };
    // },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlindedBlockV2(
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).publishBlindedBlockV2(
        body,
        ethConsensusVersion,
        broadcastValidation,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    // async publishBlindedBlockV2(
    //   body: any,
    //   ethConsensusVersion: any,
    //   broadcastValidation?: any,
    //   options?: AxiosRequestConfig
    // ): Promise<
    //   (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    // > {
    //   const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
    //     configuration
    //   ).publishBlindedBlockV2(
    //     body,
    //     ethConsensusVersion,
    //     broadcastValidation,
    //     options
    //   );
    //   return (
    //     axios: AxiosInstance = globalAxios,
    //     basePath: string = BASE_PATH
    //   ) => {
    //     const axiosRequestArgs: AxiosRequestConfig = {
    //       ...localVarAxiosArgs.options,
    //       url: basePath + localVarAxiosArgs.url,
    //     };
    //     return axios.request(axiosRequestArgs);
    //   };
    // },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlock(
      body: any,
      ethConsensusVersion?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).publishBlock(body, ethConsensusVersion, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    // async publishBlock(
    //   body: any,
    //   ethConsensusVersion?: any,
    //   options?: AxiosRequestConfig
    // ): Promise<
    //   (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    // > {
    //   const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
    //     configuration
    //   ).publishBlock(body, ethConsensusVersion, options);
    //   return (
    //     axios: AxiosInstance = globalAxios,
    //     basePath: string = BASE_PATH
    //   ) => {
    //     const axiosRequestArgs: AxiosRequestConfig = {
    //       ...localVarAxiosArgs.options,
    //       url: basePath + localVarAxiosArgs.url,
    //     };
    //     return axios.request(axiosRequestArgs);
    //   };
    // },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlockV2(
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).publishBlockV2(body, ethConsensusVersion, broadcastValidation, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    // async publishBlockV2(
    //   body: any,
    //   ethConsensusVersion: any,
    //   broadcastValidation?: any,
    //   options?: AxiosRequestConfig
    // ): Promise<
    //   (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    // > {
    //   const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
    //     configuration
    //   ).publishBlockV2(body, ethConsensusVersion, broadcastValidation, options);
    //   return (
    //     axios: AxiosInstance = globalAxios,
    //     basePath: string = BASE_PATH
    //   ) => {
    //     const axiosRequestArgs: AxiosRequestConfig = {
    //       ...localVarAxiosArgs.options,
    //       url: basePath + localVarAxiosArgs.url,
    //     };
    //     return axios.request(axiosRequestArgs);
    //   };
    // },
    /**
     * Submits Attestation objects to the node.  Each attestation in the request body is processed individually.  If an attestation is validated successfully the node MUST publish that attestation on the appropriate subnet.  If one or more attestations fail validation the node MUST return a 400 error with details of which attestations have failed, and why.
     * @summary Submit Attestation objects to node
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolAttestations(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).submitPoolAttestations(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Submits AttesterSlashing object to node's pool and if passes validation node MUST broadcast it to network.
     * @summary Submit AttesterSlashing object to node's pool
     * @param {PoolAttesterSlashingsBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolAttesterSlashings(
      body: PoolAttesterSlashingsBody,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).submitPoolAttesterSlashings(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Submits a list of SignedBLSToExecutionChange objects to node's pool. Any that pass validation MUST be broadcast to the network.
     * @summary Submit SignedBLSToExecutionChange object to node's pool
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolBLSToExecutionChange(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).submitPoolBLSToExecutionChange(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Submits ProposerSlashing object to node's pool and if passes validation  node MUST broadcast it to network.
     * @summary Submit ProposerSlashing object to node's pool
     * @param {PoolProposerSlashingsBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolProposerSlashings(
      body: PoolProposerSlashingsBody,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).submitPoolProposerSlashings(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Submits sync committee signature objects to the node.  Sync committee signatures are not present in phase0, but are required for Altair networks.  If a sync committee signature is validated successfully the node MUST publish that sync committee signature on all applicable subnets.  If one or more sync committee signatures fail validation the node MUST return a 400 error with details of which sync committee signatures have failed, and why.
     * @summary Submit sync committee signatures to node
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolSyncCommitteeSignatures(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).submitPoolSyncCommitteeSignatures(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Submits SignedVoluntaryExit object to node's pool and if passes validation node MUST broadcast it to network.
     * @summary Submit SignedVoluntaryExit object to node's pool
     * @param {PoolVoluntaryExitsBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolVoluntaryExit(
      body: PoolVoluntaryExitsBody,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await BeaconApiAxiosParamCreator(
        configuration
      ).submitPoolVoluntaryExit(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * BeaconApi - factory interface
 * @export
 */
export const BeaconApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Retrieve attestation reward info for validators specified by array of public keys or validator index. If no array is provided, return reward info for every validator.
     * @summary Get attestations rewards
     * @param {any} epoch The epoch to get rewards info from
     * @param {any} [body] An array of either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAttestationsRewards(
      epoch: any,
      body?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetAttestationsRewardsResponse>> {
      return BeaconApiFp(configuration)
        .getAttestationsRewards(epoch, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves blinded block for given block ID. Depending on `Accept` header it can be returned either as JSON or as bytes serialized by SSZ
     * @summary Get blinded block
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlindedBlock(
      blockId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetBlindedBlockResponse>> {
      return BeaconApiFp(configuration)
        .getBlindedBlock(blockId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves blob sidecars for a given block id. Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.  If the `indices` parameter is specified, only the blob sidecars with the specified indices will be returned. There are no guarantees for the returned blob sidecars in terms of ordering.
     * @summary Get blob sidecars
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {any} [indices] Array of indices for blob sidecars to request for in the specified block. Returns all blob sidecars in the block if not specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlobSidecars(
      blockId: any,
      indices?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetBlobSidecarsResponse>> {
      return BeaconApiFp(configuration)
        .getBlobSidecars(blockId, indices, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves attestation included in requested block.
     * @summary Get block attestations
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockAttestations(
      blockId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetBlockAttestationsResponse>> {
      return BeaconApiFp(configuration)
        .getBlockAttestations(blockId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves block header for given block id.
     * @summary Get block header
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockHeader(
      blockId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetBlockHeaderResponse>> {
      return BeaconApiFp(configuration)
        .getBlockHeader(blockId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves block headers matching given query. By default it will fetch current head slot blocks.
     * @summary Get block headers
     * @param {any} [slot]
     * @param {any} [parentRoot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockHeaders(
      slot?: any,
      parentRoot?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetBlockHeadersResponse>> {
      return BeaconApiFp(configuration)
        .getBlockHeaders(slot, parentRoot, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve block reward info for a single block
     * @summary Get block rewards
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockRewards(
      blockId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetBlockRewardsResponse>> {
      return BeaconApiFp(configuration)
        .getBlockRewards(blockId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader
     * @summary Get block root
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockRoot(
      blockId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetBlockRootResponse>> {
      return BeaconApiFp(configuration)
        .getBlockRoot(blockId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves block details for given block id. Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ
     * @summary Get block
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlockV2(
      blockId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetBlockV2Response>> {
      return BeaconApiFp(configuration)
        .getBlockV2(blockId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve [EIP-4881](https://eips.ethereum.org/EIPS/eip-4881) Deposit Tree Snapshot. Depending on `Accept` header it can be returned either as json or as bytes serialzed by SSZ
     * @summary Get Deposit Tree Snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDepositSnapshot(
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetDepositSnapshotResponse>> {
      return BeaconApiFp(configuration)
        .getDepositSnapshot(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the committees for the given state.
     * @summary Get all committees for a state.
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [epoch] Fetch committees for the given epoch.  If not present then the committees for the epoch of the state will be obtained.
     * @param {any} [index] Restrict returned values to those matching the supplied committee index.
     * @param {any} [slot] Restrict returned values to those matching the supplied slot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEpochCommittees(
      stateId: any,
      epoch?: any,
      index?: any,
      slot?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetEpochCommitteesResponse>> {
      return BeaconApiFp(configuration)
        .getEpochCommittees(stateId, epoch, index, slot, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the current sync committee for the given state. Also returns the subcommittee assignments.
     * @summary Get sync committees for a state.
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [epoch] Fetch sync committees for the given epoch.  If not present then the sync committees for the epoch of the state will be obtained.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEpochSyncCommittees(
      stateId: any,
      epoch?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetEpochSyncCommitteesResponse>> {
      return BeaconApiFp(configuration)
        .getEpochSyncCommittees(stateId, epoch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve details of the chain's genesis which can be used to identify chain.
     * @summary Retrieve details of the chain's genesis.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGenesis(
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetGenesisResponse>> {
      return BeaconApiFp(configuration)
        .getGenesis(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests the [`LightClientBootstrap`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientbootstrap) structure corresponding to a given post-Altair beacon block root. Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_bootstrap`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_bootstrap). To fulfill a request, the requested block's post state needs to be known.
     * @summary Get `LightClientBootstrap` structure for a requested block root
     * @param {any} blockRoot Block root. \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLightClientBootstrap(
      blockRoot: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetLightClientBootstrapResponse>> {
      return BeaconApiFp(configuration)
        .getLightClientBootstrap(blockRoot, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests the latest [`LightClientFinalityUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientfinalityupdate) known by the server. Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_finality_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_finality_update).
     * @summary Get the latest known `LightClientFinalityUpdate`
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLightClientFinalityUpdate(
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetLightClientFinalityUpdateResponse>> {
      return BeaconApiFp(configuration)
        .getLightClientFinalityUpdate(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests the latest [`LightClientOptimisticUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientoptimisticupdate) known by the server. Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_optimistic_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_optimistic_update).
     * @summary Get the latest known `LightClientOptimisticUpdate`
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLightClientOptimisticUpdate(
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetLightClientOptimisticUpdateResponse>> {
      return BeaconApiFp(configuration)
        .getLightClientOptimisticUpdate(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests the [`LightClientUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientupdate) instances in the sync committee period range `[start_period, start_period + count)`, leading up to the current head sync committee period as selected by fork choice. Depending on the `Accept` header they can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_update). They MUST respond with at least the earliest known result within the requested range, and MUST send results in consecutive order (by period). The response MUST NOT contain more than [`min(MAX_REQUEST_LIGHT_CLIENT_UPDATES, count)`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/p2p-interface.md#configuration) results.
     * @summary Get `LightClientUpdate` instances in a requested sync committee period range
     * @param {any} startPeriod
     * @param {any} count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLightClientUpdatesByRange(
      startPeriod: any,
      count: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<any>> {
      return BeaconApiFp(configuration)
        .getLightClientUpdatesByRange(startPeriod, count, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves attestations known by the node but not necessarily incorporated into any block
     * @summary Get Attestations from operations pool
     * @param {any} [slot]
     * @param {any} [committeeIndex]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoolAttestations(
      slot?: any,
      committeeIndex?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetPoolAttestationsResponse>> {
      return BeaconApiFp(configuration)
        .getPoolAttestations(slot, committeeIndex, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves attester slashings known by the node but not necessarily incorporated into any block
     * @summary Get AttesterSlashings from operations pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoolAttesterSlashings(
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetPoolAttesterSlashingsResponse>> {
      return BeaconApiFp(configuration)
        .getPoolAttesterSlashings(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves BLS to execution changes known by the node but not necessarily incorporated into any block
     * @summary Get SignedBLSToExecutionChange from operations pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoolBLSToExecutionChanges(
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetPoolBLSToExecutionChangesResponse>> {
      return BeaconApiFp(configuration)
        .getPoolBLSToExecutionChanges(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves proposer slashings known by the node but not necessarily incorporated into any block
     * @summary Get ProposerSlashings from operations pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoolProposerSlashings(
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetPoolProposerSlashingsResponse>> {
      return BeaconApiFp(configuration)
        .getPoolProposerSlashings(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves voluntary exits known by the node but not necessarily incorporated into any block
     * @summary Get SignedVoluntaryExit from operations pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoolVoluntaryExits(
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetPoolVoluntaryExitsResponse>> {
      return BeaconApiFp(configuration)
        .getPoolVoluntaryExits(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns finality checkpoints for state with given 'stateId'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root.
     * @summary Get state finality checkpoints
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateFinalityCheckpoints(
      stateId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetStateFinalityCheckpointsResponse>> {
      return BeaconApiFp(configuration)
        .getStateFinalityCheckpoints(stateId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#fork) object for state with given 'stateId'.
     * @summary Get Fork object for requested state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateFork(
      stateId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetStateForkResponse>> {
      return BeaconApiFp(configuration)
        .getStateFork(stateId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch the RANDAO mix for the requested epoch from the state identified by `state_id`.  If an epoch is not specified then the RANDAO mix for the state's current epoch will be returned.  By adjusting the `state_id` parameter you can query for any historic value of the RANDAO mix. Ordinarily states from the same epoch will mutate the RANDAO mix for that epoch as blocks are applied.
     * @summary Get the RANDAO mix for some epoch in a specified state.
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [epoch] Epoch to fetch the RANDAO mix for. Default: state&#x27;s current epoch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateRandao(
      stateId: any,
      epoch?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetStateRandaoResponse>> {
      return BeaconApiFp(configuration)
        .getStateRandao(stateId, epoch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Calculates HashTreeRoot for state with given 'stateId'. If stateId is root, same value will be returned.
     * @summary Get state SSZ HashTreeRoot
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateRoot(
      stateId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetStateRootResponse>> {
      return BeaconApiFp(configuration)
        .getStateRoot(stateId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns validator specified by state and id or public key along with status and balance.
     * @summary Get validator from state by id
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} validatorId Either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateValidator(
      stateId: any,
      validatorId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetStateValidatorResponse>> {
      return BeaconApiFp(configuration)
        .getStateValidator(stateId, validatorId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns filterable list of validators balances.  Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index is returned for each balance, and can be used to confirm for which inputs a response has been returned.
     * @summary Get validator balances from state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [id] Either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateValidatorBalances(
      stateId: any,
      id?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetStateValidatorBalancesResponse>> {
      return BeaconApiFp(configuration)
        .getStateValidatorBalances(stateId, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns filterable list of validators with their balance, status and index.  Information will be returned for all indices or public key that match known validators.  If an index or public key does not match any known validator, no information will be returned but this will not cause an error.  There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned.
     * @summary Get validators from state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [id] Either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {any} [status] [Validator status specification](https://hackmd.io/ofFJ5gOmQpu1jjHilHbdQQ)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateValidators(
      stateId: any,
      id?: any,
      status?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetStateValidatorsResponse>> {
      return BeaconApiFp(configuration)
        .getStateValidators(stateId, id, status, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves rewards info for sync committee members specified by array of public keys or validator index. If no array is provided, return reward info for every committee member.
     * @summary Get sync committee rewards
     * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @param {any} [body] An array of either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSyncCommitteeRewards(
      blockId: any,
      body?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetSyncCommitteeRewardsResponse>> {
      return BeaconApiFp(configuration)
        .getSyncCommitteeRewards(blockId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns filterable list of validators balances.  Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index is returned for each balance, and can be used to confirm for which inputs a response has been returned.
     * @summary Get validator balances from state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} [body] An array of either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postStateValidatorBalances(
      stateId: any,
      body?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetStateValidatorBalancesResponse>> {
      return BeaconApiFp(configuration)
        .postStateValidatorBalances(stateId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns filterable list of validators with their balance, status and index.  Information will be returned for all indices or public key that match known validators.  If an index or public key does not match any known validator, no information will be returned but this will not cause an error.  There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned.  The POST variant of this endpoint has the same semantics as the GET endpoint but passes the lists of IDs and statuses via a POST body in order to enable larger requests.
     * @summary Get validators from state
     * @param {StateIdValidatorsBody} body The lists of validator IDs and statuses to filter on. Either or both may be &#x60;null&#x60; to signal that no filtering on that attribute is desired.
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postStateValidators(
      body: StateIdValidatorsBody,
      stateId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetStateValidatorsResponse>> {
      return BeaconApiFp(configuration)
        .postStateValidators(body, stateId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlindedBlock(
      body: any,
      ethConsensusVersion?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return BeaconApiFp(configuration)
        .publishBlindedBlock(body, ethConsensusVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    // async publishBlindedBlock(
    //   body: any,
    //   ethConsensusVersion?: any,
    //   options?: AxiosRequestConfig
    // ): Promise<AxiosResponse<void>> {
    //   return BeaconApiFp(configuration)
    //     .publishBlindedBlock(body, ethConsensusVersion, options)
    //     .then((request) => request(axios, basePath));
    // },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlindedBlockV2(
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return BeaconApiFp(configuration)
        .publishBlindedBlockV2(
          body,
          ethConsensusVersion,
          broadcastValidation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    // async publishBlindedBlockV2(
    //   body: any,
    //   ethConsensusVersion: any,
    //   broadcastValidation?: any,
    //   options?: AxiosRequestConfig
    // ): Promise<AxiosResponse<void>> {
    //   return BeaconApiFp(configuration)
    //     .publishBlindedBlockV2(
    //       body,
    //       ethConsensusVersion,
    //       broadcastValidation,
    //       options
    //     )
    //     .then((request) => request(axios, basePath));
    // },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlock(
      body: any,
      ethConsensusVersion?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return BeaconApiFp(configuration)
        .publishBlock(body, ethConsensusVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    // async publishBlock(
    //   body: any,
    //   ethConsensusVersion?: any,
    //   options?: AxiosRequestConfig
    // ): Promise<AxiosResponse<void>> {
    //   return BeaconApiFp(configuration)
    //     .publishBlock(body, ethConsensusVersion, options)
    //     .then((request) => request(axios, basePath));
    // },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlockV2(
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return BeaconApiFp(configuration)
        .publishBlockV2(body, ethConsensusVersion, broadcastValidation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    // async publishBlockV2(
    //   body: any,
    //   ethConsensusVersion: any,
    //   broadcastValidation?: any,
    //   options?: AxiosRequestConfig
    // ): Promise<AxiosResponse<void>> {
    //   return BeaconApiFp(configuration)
    //     .publishBlockV2(body, ethConsensusVersion, broadcastValidation, options)
    //     .then((request) => request(axios, basePath));
    // },
    /**
     * Submits Attestation objects to the node.  Each attestation in the request body is processed individually.  If an attestation is validated successfully the node MUST publish that attestation on the appropriate subnet.  If one or more attestations fail validation the node MUST return a 400 error with details of which attestations have failed, and why.
     * @summary Submit Attestation objects to node
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolAttestations(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return BeaconApiFp(configuration)
        .submitPoolAttestations(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Submits AttesterSlashing object to node's pool and if passes validation node MUST broadcast it to network.
     * @summary Submit AttesterSlashing object to node's pool
     * @param {PoolAttesterSlashingsBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolAttesterSlashings(
      body: PoolAttesterSlashingsBody,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return BeaconApiFp(configuration)
        .submitPoolAttesterSlashings(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Submits a list of SignedBLSToExecutionChange objects to node's pool. Any that pass validation MUST be broadcast to the network.
     * @summary Submit SignedBLSToExecutionChange object to node's pool
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolBLSToExecutionChange(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return BeaconApiFp(configuration)
        .submitPoolBLSToExecutionChange(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Submits ProposerSlashing object to node's pool and if passes validation  node MUST broadcast it to network.
     * @summary Submit ProposerSlashing object to node's pool
     * @param {PoolProposerSlashingsBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolProposerSlashings(
      body: PoolProposerSlashingsBody,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return BeaconApiFp(configuration)
        .submitPoolProposerSlashings(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Submits sync committee signature objects to the node.  Sync committee signatures are not present in phase0, but are required for Altair networks.  If a sync committee signature is validated successfully the node MUST publish that sync committee signature on all applicable subnets.  If one or more sync committee signatures fail validation the node MUST return a 400 error with details of which sync committee signatures have failed, and why.
     * @summary Submit sync committee signatures to node
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolSyncCommitteeSignatures(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return BeaconApiFp(configuration)
        .submitPoolSyncCommitteeSignatures(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Submits SignedVoluntaryExit object to node's pool and if passes validation node MUST broadcast it to network.
     * @summary Submit SignedVoluntaryExit object to node's pool
     * @param {PoolVoluntaryExitsBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolVoluntaryExit(
      body: PoolVoluntaryExitsBody,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return BeaconApiFp(configuration)
        .submitPoolVoluntaryExit(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BeaconApi - object-oriented interface
 * @export
 * @class BeaconApi
 * @extends {BaseAPI}
 */
export class BeaconApi extends BaseAPI {
  /**
   * Retrieve attestation reward info for validators specified by array of public keys or validator index. If no array is provided, return reward info for every validator.
   * @summary Get attestations rewards
   * @param {any} epoch The epoch to get rewards info from
   * @param {any} [body] An array of either hex encoded public key (any bytes48 with 0x prefix) or validator index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getAttestationsRewards(
    epoch: any,
    body?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetAttestationsRewardsResponse>> {
    return BeaconApiFp(this.configuration)
      .getAttestationsRewards(epoch, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves blinded block for given block ID. Depending on `Accept` header it can be returned either as JSON or as bytes serialized by SSZ
   * @summary Get blinded block
   * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getBlindedBlock(
    blockId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetBlindedBlockResponse>> {
    return BeaconApiFp(this.configuration)
      .getBlindedBlock(blockId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves blob sidecars for a given block id. Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.  If the `indices` parameter is specified, only the blob sidecars with the specified indices will be returned. There are no guarantees for the returned blob sidecars in terms of ordering.
   * @summary Get blob sidecars
   * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
   * @param {any} [indices] Array of indices for blob sidecars to request for in the specified block. Returns all blob sidecars in the block if not specified.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getBlobSidecars(
    blockId: any,
    indices?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetBlobSidecarsResponse>> {
    return BeaconApiFp(this.configuration)
      .getBlobSidecars(blockId, indices, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves attestation included in requested block.
   * @summary Get block attestations
   * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getBlockAttestations(
    blockId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetBlockAttestationsResponse>> {
    return BeaconApiFp(this.configuration)
      .getBlockAttestations(blockId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves block header for given block id.
   * @summary Get block header
   * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getBlockHeader(
    blockId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetBlockHeaderResponse>> {
    return BeaconApiFp(this.configuration)
      .getBlockHeader(blockId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves block headers matching given query. By default it will fetch current head slot blocks.
   * @summary Get block headers
   * @param {any} [slot]
   * @param {any} [parentRoot]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getBlockHeaders(
    slot?: any,
    parentRoot?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetBlockHeadersResponse>> {
    return BeaconApiFp(this.configuration)
      .getBlockHeaders(slot, parentRoot, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieve block reward info for a single block
   * @summary Get block rewards
   * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getBlockRewards(
    blockId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetBlockRewardsResponse>> {
    return BeaconApiFp(this.configuration)
      .getBlockRewards(blockId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader
   * @summary Get block root
   * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getBlockRoot(
    blockId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetBlockRootResponse>> {
    return BeaconApiFp(this.configuration)
      .getBlockRoot(blockId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves block details for given block id. Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ
   * @summary Get block
   * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getBlockV2(
    blockId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetBlockV2Response>> {
    return BeaconApiFp(this.configuration)
      .getBlockV2(blockId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieve [EIP-4881](https://eips.ethereum.org/EIPS/eip-4881) Deposit Tree Snapshot. Depending on `Accept` header it can be returned either as json or as bytes serialzed by SSZ
   * @summary Get Deposit Tree Snapshot
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getDepositSnapshot(
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetDepositSnapshotResponse>> {
    return BeaconApiFp(this.configuration)
      .getDepositSnapshot(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the committees for the given state.
   * @summary Get all committees for a state.
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {any} [epoch] Fetch committees for the given epoch.  If not present then the committees for the epoch of the state will be obtained.
   * @param {any} [index] Restrict returned values to those matching the supplied committee index.
   * @param {any} [slot] Restrict returned values to those matching the supplied slot.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getEpochCommittees(
    stateId: any,
    epoch?: any,
    index?: any,
    slot?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetEpochCommitteesResponse>> {
    return BeaconApiFp(this.configuration)
      .getEpochCommittees(stateId, epoch, index, slot, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the current sync committee for the given state. Also returns the subcommittee assignments.
   * @summary Get sync committees for a state.
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {any} [epoch] Fetch sync committees for the given epoch.  If not present then the sync committees for the epoch of the state will be obtained.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getEpochSyncCommittees(
    stateId: any,
    epoch?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetEpochSyncCommitteesResponse>> {
    return BeaconApiFp(this.configuration)
      .getEpochSyncCommittees(stateId, epoch, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieve details of the chain's genesis which can be used to identify chain.
   * @summary Retrieve details of the chain's genesis.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getGenesis(
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetGenesisResponse>> {
    return BeaconApiFp(this.configuration)
      .getGenesis(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Requests the [`LightClientBootstrap`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientbootstrap) structure corresponding to a given post-Altair beacon block root. Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_bootstrap`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_bootstrap). To fulfill a request, the requested block's post state needs to be known.
   * @summary Get `LightClientBootstrap` structure for a requested block root
   * @param {any} blockRoot Block root. \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getLightClientBootstrap(
    blockRoot: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetLightClientBootstrapResponse>> {
    return BeaconApiFp(this.configuration)
      .getLightClientBootstrap(blockRoot, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Requests the latest [`LightClientFinalityUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientfinalityupdate) known by the server. Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_finality_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_finality_update).
   * @summary Get the latest known `LightClientFinalityUpdate`
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getLightClientFinalityUpdate(
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetLightClientFinalityUpdateResponse>> {
    return BeaconApiFp(this.configuration)
      .getLightClientFinalityUpdate(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Requests the latest [`LightClientOptimisticUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientoptimisticupdate) known by the server. Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_optimistic_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_optimistic_update).
   * @summary Get the latest known `LightClientOptimisticUpdate`
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getLightClientOptimisticUpdate(
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetLightClientOptimisticUpdateResponse>> {
    return BeaconApiFp(this.configuration)
      .getLightClientOptimisticUpdate(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Requests the [`LightClientUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.md#lightclientupdate) instances in the sync committee period range `[start_period, start_period + count)`, leading up to the current head sync committee period as selected by fork choice. Depending on the `Accept` header they can be returned either as JSON or SSZ-serialized bytes.  Servers SHOULD provide results as defined in [`create_light_client_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.md#create_light_client_update). They MUST respond with at least the earliest known result within the requested range, and MUST send results in consecutive order (by period). The response MUST NOT contain more than [`min(MAX_REQUEST_LIGHT_CLIENT_UPDATES, count)`](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/p2p-interface.md#configuration) results.
   * @summary Get `LightClientUpdate` instances in a requested sync committee period range
   * @param {any} startPeriod
   * @param {any} count
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getLightClientUpdatesByRange(
    startPeriod: any,
    count: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<any>> {
    return BeaconApiFp(this.configuration)
      .getLightClientUpdatesByRange(startPeriod, count, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves attestations known by the node but not necessarily incorporated into any block
   * @summary Get Attestations from operations pool
   * @param {any} [slot]
   * @param {any} [committeeIndex]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getPoolAttestations(
    slot?: any,
    committeeIndex?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetPoolAttestationsResponse>> {
    return BeaconApiFp(this.configuration)
      .getPoolAttestations(slot, committeeIndex, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves attester slashings known by the node but not necessarily incorporated into any block
   * @summary Get AttesterSlashings from operations pool
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getPoolAttesterSlashings(
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetPoolAttesterSlashingsResponse>> {
    return BeaconApiFp(this.configuration)
      .getPoolAttesterSlashings(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves BLS to execution changes known by the node but not necessarily incorporated into any block
   * @summary Get SignedBLSToExecutionChange from operations pool
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getPoolBLSToExecutionChanges(
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetPoolBLSToExecutionChangesResponse>> {
    return BeaconApiFp(this.configuration)
      .getPoolBLSToExecutionChanges(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves proposer slashings known by the node but not necessarily incorporated into any block
   * @summary Get ProposerSlashings from operations pool
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getPoolProposerSlashings(
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetPoolProposerSlashingsResponse>> {
    return BeaconApiFp(this.configuration)
      .getPoolProposerSlashings(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves voluntary exits known by the node but not necessarily incorporated into any block
   * @summary Get SignedVoluntaryExit from operations pool
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getPoolVoluntaryExits(
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetPoolVoluntaryExitsResponse>> {
    return BeaconApiFp(this.configuration)
      .getPoolVoluntaryExits(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns finality checkpoints for state with given 'stateId'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root.
   * @summary Get state finality checkpoints
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getStateFinalityCheckpoints(
    stateId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetStateFinalityCheckpointsResponse>> {
    return BeaconApiFp(this.configuration)
      .getStateFinalityCheckpoints(stateId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#fork) object for state with given 'stateId'.
   * @summary Get Fork object for requested state
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getStateFork(
    stateId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetStateForkResponse>> {
    return BeaconApiFp(this.configuration)
      .getStateFork(stateId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Fetch the RANDAO mix for the requested epoch from the state identified by `state_id`.  If an epoch is not specified then the RANDAO mix for the state's current epoch will be returned.  By adjusting the `state_id` parameter you can query for any historic value of the RANDAO mix. Ordinarily states from the same epoch will mutate the RANDAO mix for that epoch as blocks are applied.
   * @summary Get the RANDAO mix for some epoch in a specified state.
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {any} [epoch] Epoch to fetch the RANDAO mix for. Default: state&#x27;s current epoch.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getStateRandao(
    stateId: any,
    epoch?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetStateRandaoResponse>> {
    return BeaconApiFp(this.configuration)
      .getStateRandao(stateId, epoch, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Calculates HashTreeRoot for state with given 'stateId'. If stateId is root, same value will be returned.
   * @summary Get state SSZ HashTreeRoot
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getStateRoot(
    stateId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetStateRootResponse>> {
    return BeaconApiFp(this.configuration)
      .getStateRoot(stateId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns validator specified by state and id or public key along with status and balance.
   * @summary Get validator from state by id
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {any} validatorId Either hex encoded public key (any bytes48 with 0x prefix) or validator index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getStateValidator(
    stateId: any,
    validatorId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetStateValidatorResponse>> {
    return BeaconApiFp(this.configuration)
      .getStateValidator(stateId, validatorId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns filterable list of validators balances.  Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index is returned for each balance, and can be used to confirm for which inputs a response has been returned.
   * @summary Get validator balances from state
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {any} [id] Either hex encoded public key (any bytes48 with 0x prefix) or validator index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getStateValidatorBalances(
    stateId: any,
    id?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetStateValidatorBalancesResponse>> {
    return BeaconApiFp(this.configuration)
      .getStateValidatorBalances(stateId, id, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns filterable list of validators with their balance, status and index.  Information will be returned for all indices or public key that match known validators.  If an index or public key does not match any known validator, no information will be returned but this will not cause an error.  There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned.
   * @summary Get validators from state
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {any} [id] Either hex encoded public key (any bytes48 with 0x prefix) or validator index
   * @param {any} [status] [Validator status specification](https://hackmd.io/ofFJ5gOmQpu1jjHilHbdQQ)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getStateValidators(
    stateId: any,
    id?: any,
    status?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetStateValidatorsResponse>> {
    return BeaconApiFp(this.configuration)
      .getStateValidators(stateId, id, status, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves rewards info for sync committee members specified by array of public keys or validator index. If no array is provided, return reward info for every committee member.
   * @summary Get sync committee rewards
   * @param {any} blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
   * @param {any} [body] An array of either hex encoded public key (any bytes48 with 0x prefix) or validator index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async getSyncCommitteeRewards(
    blockId: any,
    body?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetSyncCommitteeRewardsResponse>> {
    return BeaconApiFp(this.configuration)
      .getSyncCommitteeRewards(blockId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns filterable list of validators balances.  Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index is returned for each balance, and can be used to confirm for which inputs a response has been returned.
   * @summary Get validator balances from state
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {any} [body] An array of either hex encoded public key (any bytes48 with 0x prefix) or validator index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async postStateValidatorBalances(
    stateId: any,
    body?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetStateValidatorBalancesResponse>> {
    return BeaconApiFp(this.configuration)
      .postStateValidatorBalances(stateId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns filterable list of validators with their balance, status and index.  Information will be returned for all indices or public key that match known validators.  If an index or public key does not match any known validator, no information will be returned but this will not cause an error.  There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned.  The POST variant of this endpoint has the same semantics as the GET endpoint but passes the lists of IDs and statuses via a POST body in order to enable larger requests.
   * @summary Get validators from state
   * @param {StateIdValidatorsBody} body The lists of validator IDs and statuses to filter on. Either or both may be &#x60;null&#x60; to signal that no filtering on that attribute is desired.
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async postStateValidators(
    body: StateIdValidatorsBody,
    stateId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetStateValidatorsResponse>> {
    return BeaconApiFp(this.configuration)
      .postStateValidators(body, stateId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async publishBlindedBlock(
    body: any,
    ethConsensusVersion?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return BeaconApiFp(this.configuration)
      .publishBlindedBlock(body, ethConsensusVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  // public async publishBlindedBlock(
  //   body: any,
  //   ethConsensusVersion?: any,
  //   options?: AxiosRequestConfig
  // ): Promise<AxiosResponse<void>> {
  //   return BeaconApiFp(this.configuration)
  //     .publishBlindedBlock(body, ethConsensusVersion, options)
  //     .then((request) => request(this.axios, this.basePath));
  // }
  /**
   * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} ethConsensusVersion Version of the block being submitted.
   * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  // public async publishBlindedBlockV2(
  //   body: any,
  //   ethConsensusVersion: any,
  //   broadcastValidation?: any,
  //   options?: AxiosRequestConfig
  // ): Promise<AxiosResponse<void>> {
  //   return BeaconApiFp(this.configuration)
  //     .publishBlindedBlockV2(
  //       body,
  //       ethConsensusVersion,
  //       broadcastValidation,
  //       options
  //     )
  //     .then((request) => request(this.axios, this.basePath));
  // }

  /**
   * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} ethConsensusVersion Version of the block being submitted.
   * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async publishBlindedBlockV2(
    body: any,
    ethConsensusVersion: any,
    broadcastValidation?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return BeaconApiFp(this.configuration)
      .publishBlindedBlockV2(
        body,
        ethConsensusVersion,
        broadcastValidation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async publishBlock(
    body: any,
    ethConsensusVersion?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return BeaconApiFp(this.configuration)
      .publishBlock(body, ethConsensusVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  // public async publishBlock(
  //   body: any,
  //   ethConsensusVersion?: any,
  //   options?: AxiosRequestConfig
  // ): Promise<AxiosResponse<void>> {
  //   return BeaconApiFp(this.configuration)
  //     .publishBlock(body, ethConsensusVersion, options)
  //     .then((request) => request(this.axios, this.basePath));
  // }
  /**
   * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} ethConsensusVersion Version of the block being submitted.
   * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async publishBlockV2(
    body: any,
    ethConsensusVersion: any,
    broadcastValidation?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return BeaconApiFp(this.configuration)
      .publishBlockV2(body, ethConsensusVersion, broadcastValidation, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} ethConsensusVersion Version of the block being submitted.
   * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  // public async publishBlockV2(
  //   body: any,
  //   ethConsensusVersion: any,
  //   broadcastValidation?: any,
  //   options?: AxiosRequestConfig
  // ): Promise<AxiosResponse<void>> {
  //   return BeaconApiFp(this.configuration)
  //     .publishBlockV2(body, ethConsensusVersion, broadcastValidation, options)
  //     .then((request) => request(this.axios, this.basePath));
  // }
  /**
   * Submits Attestation objects to the node.  Each attestation in the request body is processed individually.  If an attestation is validated successfully the node MUST publish that attestation on the appropriate subnet.  If one or more attestations fail validation the node MUST return a 400 error with details of which attestations have failed, and why.
   * @summary Submit Attestation objects to node
   * @param {any} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async submitPoolAttestations(
    body: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return BeaconApiFp(this.configuration)
      .submitPoolAttestations(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Submits AttesterSlashing object to node's pool and if passes validation node MUST broadcast it to network.
   * @summary Submit AttesterSlashing object to node's pool
   * @param {PoolAttesterSlashingsBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async submitPoolAttesterSlashings(
    body: PoolAttesterSlashingsBody,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return BeaconApiFp(this.configuration)
      .submitPoolAttesterSlashings(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Submits a list of SignedBLSToExecutionChange objects to node's pool. Any that pass validation MUST be broadcast to the network.
   * @summary Submit SignedBLSToExecutionChange object to node's pool
   * @param {any} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async submitPoolBLSToExecutionChange(
    body: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return BeaconApiFp(this.configuration)
      .submitPoolBLSToExecutionChange(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Submits ProposerSlashing object to node's pool and if passes validation  node MUST broadcast it to network.
   * @summary Submit ProposerSlashing object to node's pool
   * @param {PoolProposerSlashingsBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async submitPoolProposerSlashings(
    body: PoolProposerSlashingsBody,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return BeaconApiFp(this.configuration)
      .submitPoolProposerSlashings(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Submits sync committee signature objects to the node.  Sync committee signatures are not present in phase0, but are required for Altair networks.  If a sync committee signature is validated successfully the node MUST publish that sync committee signature on all applicable subnets.  If one or more sync committee signatures fail validation the node MUST return a 400 error with details of which sync committee signatures have failed, and why.
   * @summary Submit sync committee signatures to node
   * @param {any} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async submitPoolSyncCommitteeSignatures(
    body: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return BeaconApiFp(this.configuration)
      .submitPoolSyncCommitteeSignatures(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Submits SignedVoluntaryExit object to node's pool and if passes validation node MUST broadcast it to network.
   * @summary Submit SignedVoluntaryExit object to node's pool
   * @param {PoolVoluntaryExitsBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconApi
   */
  public async submitPoolVoluntaryExit(
    body: PoolVoluntaryExitsBody,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return BeaconApiFp(this.configuration)
      .submitPoolVoluntaryExit(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
