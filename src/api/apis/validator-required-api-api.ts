/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * Eth Beacon Node API
 * API specification for the beacon node, which enables users to query and participate in Ethereum 2.0 phase 0 beacon chain.  All requests by default send and receive JSON, and as such should have either or both of the \"Content-Type: application/json\" and \"Accept: application/json\" headers.  In addition, some requests can return data in the SSZ format.  To indicate that SSZ data is required in response to a request the header \"Accept: application/octet-stream\" should be sent.  Note that only a subset of requests can respond with data in SSZ format; these are noted in each individual request.  API endpoints are individually versioned.  As such, there is no direct relationship between all v1 endpoints, all v2 endpoints, _etc._ and no such relationship should be inferred.  All JSON responses return the requested data under a `data` key in the top level of their response.  Additional metadata may or may not be present in other keys at the top level of the response, dependent on the endpoint.  The rules that require an increase in version number are as follows:    - no field that is listed in an endpoint shall be removed without an increase in the version number   - no field that is listed in an endpoint shall be altered in terms of format (_e.g._ from a string to an array) without an     increase in the version number  Note that it is possible for a field to be added to an endpoint's data or metadata without an increase in the version number.
 *
 * OpenAPI spec version: v2.5.0 - Ethereum Proof-of-Stake Consensus Specification v1.4.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosResponse,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../base";
import { GetAggregatedAttestationResponse } from "../models";
import { GetAttesterDutiesResponse } from "../models";
import { GetGenesisResponse } from "../models";
import { GetProposerDutiesResponse } from "../models";
import { GetSpecResponse } from "../models";
import { GetStateForkResponse } from "../models";
import { GetStateValidatorResponse } from "../models";
import { GetSyncCommitteeDutiesResponse } from "../models";
import { GetSyncingStatusResponse } from "../models";
import { InlineResponse400 } from "../models";
import { InlineResponse4001 } from "../models";
import { InlineResponse404 } from "../models";
import { InlineResponse415 } from "../models";
import { ProduceAttestationDataResponse } from "../models";
import { ProduceBlindedBlockResponse } from "../models";
import { ProduceBlockV2Response } from "../models";
import { ProduceBlockV3Response } from "../models";
import { ProduceSyncCommitteeContributionResponse } from "../models";
/**
 * ValidatorRequiredApiApi - axios parameter creator
 * @export
 */
export const ValidatorRequiredApiApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Provides endpoint to subscribe to beacon node Server-Sent-Events stream. Consumers should use [eventsource](https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface) implementation to listen on those events.  Servers _may_ send SSE comments beginning with `:` for any purpose, including to keep the event stream connection alive in the presence of proxy servers.
     * @summary Subscribe to beacon node events
     * @param {any} topics Event types to subscribe to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventstream: async (
      topics: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'topics' is not null or undefined
      if (topics === null || topics === undefined) {
        throw new RequiredError(
          "topics",
          "Required parameter topics was null or undefined when calling eventstream."
        );
      }
      const localVarPath = `/eth/v1/events`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (topics !== undefined) {
        localVarQueryParameter["topics"] = topics;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Aggregates all attestations matching given attestation data root and slot.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the aggregated attestation attests to a block that has not been fully verified by an execution engine).  A 404 error must be returned if no attestation is available for the requested `attestation_data_root`.
     * @summary Get aggregated attestation
     * @param {any} attestationDataRoot HashTreeRoot of AttestationData that validator wants aggregated
     * @param {any} slot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAggregatedAttestation: async (
      attestationDataRoot: any,
      slot: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'attestationDataRoot' is not null or undefined
      if (attestationDataRoot === null || attestationDataRoot === undefined) {
        throw new RequiredError(
          "attestationDataRoot",
          "Required parameter attestationDataRoot was null or undefined when calling getAggregatedAttestation."
        );
      }
      // verify required parameter 'slot' is not null or undefined
      if (slot === null || slot === undefined) {
        throw new RequiredError(
          "slot",
          "Required parameter slot was null or undefined when calling getAggregatedAttestation."
        );
      }
      const localVarPath = `/eth/v1/validator/aggregate_attestation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (attestationDataRoot !== undefined) {
        localVarQueryParameter["attestation_data_root"] = attestationDataRoot;
      }

      if (slot !== undefined) {
        localVarQueryParameter["slot"] = slot;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests the beacon node to provide a set of attestation duties, which should be performed by validators, for a particular epoch. Duties should only need to be checked once per epoch, however a chain reorganization (of > MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.previous_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) + 1 == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1) - 1)` or the genesis block root in the case of underflow.
     * @summary Get attester duties
     * @param {any} body An array of the validator indices for which to obtain the duties.
     * @param {any} epoch Should only be allowed 1 epoch ahead
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttesterDuties: async (
      body: any,
      epoch: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling getAttesterDuties."
        );
      }
      // verify required parameter 'epoch' is not null or undefined
      if (epoch === null || epoch === undefined) {
        throw new RequiredError(
          "epoch",
          "Required parameter epoch was null or undefined when calling getAttesterDuties."
        );
      }
      const localVarPath = `/eth/v1/validator/duties/attester/{epoch}`.replace(
        `{${"epoch"}}`,
        encodeURIComponent(String(epoch))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve details of the chain's genesis which can be used to identify chain.
     * @summary Retrieve details of the chain's genesis.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGenesis: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/beacon/genesis`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1)` or the genesis block root in the case of underflow.
     * @summary Get block proposers duties
     * @param {any} epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProposerDuties: async (
      epoch: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'epoch' is not null or undefined
      if (epoch === null || epoch === undefined) {
        throw new RequiredError(
          "epoch",
          "Required parameter epoch was null or undefined when calling getProposerDuties."
        );
      }
      const localVarPath = `/eth/v1/validator/duties/proposer/{epoch}`.replace(
        `{${"epoch"}}`,
        encodeURIComponent(String(epoch))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve specification configuration used on this node.  The configuration should include:   - Constants for all hard forks known by the beacon node, for example the [phase 0](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#constants) and [altair](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/beacon-chain.md#constants) values   - Presets for all hard forks supplied to the beacon node, for example the [phase 0](https://github.com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/phase0.yaml) and [altair](https://github.com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/altair.yaml) values   - Configuration for the beacon node, for example the [mainnet](https://github.com/ethereum/consensus-specs/blob/v1.3.0/configs/mainnet.yaml) values  Values are returned with following format:   - any value starting with 0x in the spec is returned as a hex string   - numeric values are returned as a quoted integer
     * @summary Get spec params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSpec: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/config/spec`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#fork) object for state with given 'stateId'.
     * @summary Get Fork object for requested state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStateFork: async (
      stateId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling getStateFork."
        );
      }
      const localVarPath = `/eth/v1/beacon/states/{state_id}/fork`.replace(
        `{${"state_id"}}`,
        encodeURIComponent(String(stateId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns validator specified by state and id or public key along with status and balance.
     * @summary Get validator from state by id
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} validatorId Either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStateValidator: async (
      stateId: any,
      validatorId: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stateId' is not null or undefined
      if (stateId === null || stateId === undefined) {
        throw new RequiredError(
          "stateId",
          "Required parameter stateId was null or undefined when calling getStateValidator."
        );
      }
      // verify required parameter 'validatorId' is not null or undefined
      if (validatorId === null || validatorId === undefined) {
        throw new RequiredError(
          "validatorId",
          "Required parameter validatorId was null or undefined when calling getStateValidator."
        );
      }
      const localVarPath =
        `/eth/v1/beacon/states/{state_id}/validators/{validator_id}`
          .replace(`{${"state_id"}}`, encodeURIComponent(String(stateId)))
          .replace(
            `{${"validator_id"}}`,
            encodeURIComponent(String(validatorId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests the beacon node to provide a set of sync committee duties for a particular epoch.
     * @summary Get sync committee duties
     * @param {any} body An array of the validator indices for which to obtain the duties.
     * @param {any} epoch epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD &lt;&#x3D; current_epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD + 1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSyncCommitteeDuties: async (
      body: any,
      epoch: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling getSyncCommitteeDuties."
        );
      }
      // verify required parameter 'epoch' is not null or undefined
      if (epoch === null || epoch === undefined) {
        throw new RequiredError(
          "epoch",
          "Required parameter epoch was null or undefined when calling getSyncCommitteeDuties."
        );
      }
      const localVarPath = `/eth/v1/validator/duties/sync/{epoch}`.replace(
        `{${"epoch"}}`,
        encodeURIComponent(String(epoch))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to.
     * @summary Get node syncing status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSyncingStatus: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/eth/v1/node/syncing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * After beacon node receives this request, search using discv5 for peers related to this subnet and replace current peers with those ones if necessary If validator `is_aggregator`, beacon node must: - announce subnet topic subscription on gossipsub - aggregate attestations received on that subnet
     * @summary Signal beacon node to prepare for a committee subnet
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    prepareBeaconCommitteeSubnet: async (
      body: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling prepareBeaconCommitteeSubnet."
        );
      }
      const localVarPath = `/eth/v1/validator/beacon_committee_subscriptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Prepares the beacon node for potential proposers by supplying information required when proposing blocks for the given validators.  The information supplied for each validator index will persist through the epoch in which the call is submitted and for a further two epochs after that, or until the beacon node restarts.  It is expected that validator clients will send this information periodically, for example each epoch, to ensure beacon nodes have correct and timely fee recipient information.  Note that there is no guarantee that the beacon node will use the supplied fee recipient when creating a block proposal, so on receipt of a proposed block the validator should confirm that it finds the fee recipient within the block acceptable before signing it.  Also note that requests containing currently inactive or unknown validator indices will be accepted, as they may become active at a later epoch.
     * @summary Provide beacon node with proposals for the given validators.
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    prepareBeaconProposer: async (
      body: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling prepareBeaconProposer."
        );
      }
      const localVarPath = `/eth/v1/validator/prepare_beacon_proposer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Subscribe to a number of sync committee subnets  Sync committees are not present in phase0, but are required for Altair networks.  Subscribing to sync committee subnets is an action performed by VC to enable network participation in Altair networks, and only required if the VC has an active validator in an active sync committee.
     * @summary Subscribe to sync committee subnets
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    prepareSyncCommitteeSubnets: async (
      body: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling prepareSyncCommitteeSubnets."
        );
      }
      const localVarPath = `/eth/v1/validator/sync_committee_subscriptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests that the beacon node produce an AttestationData.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the attestation attests to a block that has not been fully verified by an execution engine).
     * @summary Produce an attestation data
     * @param {any} slot The slot for which an attestation data should be created.
     * @param {any} committeeIndex The committee index for which an attestation data should be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    produceAttestationData: async (
      slot: any,
      committeeIndex: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'slot' is not null or undefined
      if (slot === null || slot === undefined) {
        throw new RequiredError(
          "slot",
          "Required parameter slot was null or undefined when calling produceAttestationData."
        );
      }
      // verify required parameter 'committeeIndex' is not null or undefined
      if (committeeIndex === null || committeeIndex === undefined) {
        throw new RequiredError(
          "committeeIndex",
          "Required parameter committeeIndex was null or undefined when calling produceAttestationData."
        );
      }
      const localVarPath = `/eth/v1/validator/attestation_data`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (slot !== undefined) {
        localVarQueryParameter["slot"] = slot;
      }

      if (committeeIndex !== undefined) {
        localVarQueryParameter["committee_index"] = committeeIndex;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests a beacon node to produce a valid blinded block, which can then be signed by a validator.  A blinded block is a block with only a transactions root, rather than a full transactions list.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.  Before Bellatrix, this endpoint will return a `BeaconBlock`.
     * @summary Produce a new blinded block, without signature.
     * @param {any} slot The slot for which the block should be proposed.
     * @param {any} randaoReveal The validator&#x27;s randao reveal value.
     * @param {any} [graffiti] Arbitrary data validator wants to include in block.
     * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    produceBlindedBlock: async (
      slot: any,
      randaoReveal: any,
      graffiti?: any,
      skipRandaoVerification?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'slot' is not null or undefined
      if (slot === null || slot === undefined) {
        throw new RequiredError(
          "slot",
          "Required parameter slot was null or undefined when calling produceBlindedBlock."
        );
      }
      // verify required parameter 'randaoReveal' is not null or undefined
      if (randaoReveal === null || randaoReveal === undefined) {
        throw new RequiredError(
          "randaoReveal",
          "Required parameter randaoReveal was null or undefined when calling produceBlindedBlock."
        );
      }
      const localVarPath = `/eth/v1/validator/blinded_blocks/{slot}`.replace(
        `{${"slot"}}`,
        encodeURIComponent(String(slot))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (randaoReveal !== undefined) {
        localVarQueryParameter["randao_reveal"] = randaoReveal;
      }

      if (graffiti !== undefined) {
        localVarQueryParameter["graffiti"] = graffiti;
      }

      if (skipRandaoVerification !== undefined) {
        localVarQueryParameter["skip_randao_verification"] =
          skipRandaoVerification;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests a beacon node to produce a valid block, which can then be signed by a validator.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.
     * @summary Produce a new block, without signature.
     * @param {any} slot The slot for which the block should be proposed.
     * @param {any} randaoReveal The validator&#x27;s randao reveal value.
     * @param {any} [graffiti] Arbitrary data validator wants to include in block.
     * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    produceBlockV2: async (
      slot: any,
      randaoReveal: any,
      graffiti?: any,
      skipRandaoVerification?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'slot' is not null or undefined
      if (slot === null || slot === undefined) {
        throw new RequiredError(
          "slot",
          "Required parameter slot was null or undefined when calling produceBlockV2."
        );
      }
      // verify required parameter 'randaoReveal' is not null or undefined
      if (randaoReveal === null || randaoReveal === undefined) {
        throw new RequiredError(
          "randaoReveal",
          "Required parameter randaoReveal was null or undefined when calling produceBlockV2."
        );
      }
      const localVarPath = `/eth/v2/validator/blocks/{slot}`.replace(
        `{${"slot"}}`,
        encodeURIComponent(String(slot))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (randaoReveal !== undefined) {
        localVarQueryParameter["randao_reveal"] = randaoReveal;
      }

      if (graffiti !== undefined) {
        localVarQueryParameter["graffiti"] = graffiti;
      }

      if (skipRandaoVerification !== undefined) {
        localVarQueryParameter["skip_randao_verification"] =
          skipRandaoVerification;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests a beacon node to produce a valid block, which can then be signed by a validator. The returned block may be blinded or unblinded, depending on the current state of the network as decided by the execution and beacon nodes.  The beacon node must return an unblinded block if it obtains the execution payload from its paired execution node. It must only return a blinded block if it obtains the execution payload header from an MEV relay.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.
     * @summary Produce a new block, without signature.
     * @param {any} slot The slot for which the block should be proposed.
     * @param {any} randaoReveal The validator&#x27;s randao reveal value.
     * @param {any} [graffiti] Arbitrary data validator wants to include in block.
     * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value.
     * @param {any} [builderBoostFactor] Percentage multiplier to apply to the builder&#x27;s payload value when choosing between a builder payload header and payload from the paired execution node. This parameter is only relevant if the beacon node is connected to a builder, deems it safe to produce a builder payload, and receives valid responses from both the builder endpoint _and_ the paired execution node. When these preconditions are met, the server MUST act as follows:  * if &#x60;exec_node_payload_value &gt;&#x3D; builder_boost_factor * (builder_payload_value // 100)&#x60;,   then return a full (unblinded) block containing the execution node payload. * otherwise, return a blinded block containing the builder payload header.  Servers must support the following values of the boost factor which encode common preferences:  * &#x60;builder_boost_factor&#x3D;0&#x60;: prefer the execution node payload unless an error makes it   unviable. * &#x60;builder_boost_factor&#x3D;100&#x60;: default profit maximization mode; choose whichever   payload pays more. * &#x60;builder_boost_factor&#x3D;2**64 - 1&#x60;: prefer the builder payload unless an error or   beacon node health check makes it unviable.  Servers should use saturating arithmetic or another technique to ensure that large values of the &#x60;builder_boost_factor&#x60; do not trigger overflows or errors. If this parameter is provided and the beacon node is not configured with a builder then the beacon node MUST respond with a full block, which the caller can choose to reject if it wishes. If this parameter is **not** provided then it should be treated as having the default value of 100. If the value is provided but out of range for a 64-bit unsigned integer, then an error response with status code 400 MUST be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    produceBlockV3: async (
      slot: any,
      randaoReveal: any,
      graffiti?: any,
      skipRandaoVerification?: any,
      builderBoostFactor?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'slot' is not null or undefined
      if (slot === null || slot === undefined) {
        throw new RequiredError(
          "slot",
          "Required parameter slot was null or undefined when calling produceBlockV3."
        );
      }
      // verify required parameter 'randaoReveal' is not null or undefined
      if (randaoReveal === null || randaoReveal === undefined) {
        throw new RequiredError(
          "randaoReveal",
          "Required parameter randaoReveal was null or undefined when calling produceBlockV3."
        );
      }
      const localVarPath = `/eth/v3/validator/blocks/{slot}`.replace(
        `{${"slot"}}`,
        encodeURIComponent(String(slot))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (randaoReveal !== undefined) {
        localVarQueryParameter["randao_reveal"] = randaoReveal;
      }

      if (graffiti !== undefined) {
        localVarQueryParameter["graffiti"] = graffiti;
      }

      if (skipRandaoVerification !== undefined) {
        localVarQueryParameter["skip_randao_verification"] =
          skipRandaoVerification;
      }

      if (builderBoostFactor !== undefined) {
        localVarQueryParameter["builder_boost_factor"] = builderBoostFactor;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests that the beacon node produce a sync committee contribution.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the sync committee contribution refers to a block that has not been fully verified by an execution engine).
     * @summary Produce a sync committee contribution
     * @param {any} slot The slot for which a sync committee contribution should be created.
     * @param {any} subcommitteeIndex the subcommittee index for which to produce the contribution.
     * @param {any} beaconBlockRoot the block root for which to produce the contribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    produceSyncCommitteeContribution: async (
      slot: any,
      subcommitteeIndex: any,
      beaconBlockRoot: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'slot' is not null or undefined
      if (slot === null || slot === undefined) {
        throw new RequiredError(
          "slot",
          "Required parameter slot was null or undefined when calling produceSyncCommitteeContribution."
        );
      }
      // verify required parameter 'subcommitteeIndex' is not null or undefined
      if (subcommitteeIndex === null || subcommitteeIndex === undefined) {
        throw new RequiredError(
          "subcommitteeIndex",
          "Required parameter subcommitteeIndex was null or undefined when calling produceSyncCommitteeContribution."
        );
      }
      // verify required parameter 'beaconBlockRoot' is not null or undefined
      if (beaconBlockRoot === null || beaconBlockRoot === undefined) {
        throw new RequiredError(
          "beaconBlockRoot",
          "Required parameter beaconBlockRoot was null or undefined when calling produceSyncCommitteeContribution."
        );
      }
      const localVarPath = `/eth/v1/validator/sync_committee_contribution`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (slot !== undefined) {
        localVarQueryParameter["slot"] = slot;
      }

      if (subcommitteeIndex !== undefined) {
        localVarQueryParameter["subcommittee_index"] = subcommitteeIndex;
      }

      if (beaconBlockRoot !== undefined) {
        localVarQueryParameter["beacon_block_root"] = beaconBlockRoot;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
     * @summary Publish multiple aggregate and proofs
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishAggregateAndProofs: async (
      body: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishAggregateAndProofs."
        );
      }
      const localVarPath = `/eth/v1/validator/aggregate_and_proofs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlindedBlock: async (
      body: any,
      ethConsensusVersion?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlindedBlock."
        );
      }
      const localVarPath = `/eth/v1/beacon/blinded_blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlindedBlock: async (
      body: any,
      ethConsensusVersion?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlindedBlock."
        );
      }
      const localVarPath = `/eth/v1/beacon/blinded_blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlindedBlockV2: async (
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlindedBlockV2."
        );
      }
      // verify required parameter 'ethConsensusVersion' is not null or undefined
      if (ethConsensusVersion === null || ethConsensusVersion === undefined) {
        throw new RequiredError(
          "ethConsensusVersion",
          "Required parameter ethConsensusVersion was null or undefined when calling publishBlindedBlockV2."
        );
      }
      const localVarPath = `/eth/v2/beacon/blinded_blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (broadcastValidation !== undefined) {
        localVarQueryParameter["broadcast_validation"] = broadcastValidation;
      }

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlindedBlockV2: async (
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlindedBlockV2."
        );
      }
      // verify required parameter 'ethConsensusVersion' is not null or undefined
      if (ethConsensusVersion === null || ethConsensusVersion === undefined) {
        throw new RequiredError(
          "ethConsensusVersion",
          "Required parameter ethConsensusVersion was null or undefined when calling publishBlindedBlockV2."
        );
      }
      const localVarPath = `/eth/v2/beacon/blinded_blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (broadcastValidation !== undefined) {
        localVarQueryParameter["broadcast_validation"] = broadcastValidation;
      }

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlock: async (
      body: any,
      ethConsensusVersion?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlock."
        );
      }
      const localVarPath = `/eth/v1/beacon/blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlock: async (
      body: any,
      ethConsensusVersion?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlock."
        );
      }
      const localVarPath = `/eth/v1/beacon/blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlockV2: async (
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlockV2."
        );
      }
      // verify required parameter 'ethConsensusVersion' is not null or undefined
      if (ethConsensusVersion === null || ethConsensusVersion === undefined) {
        throw new RequiredError(
          "ethConsensusVersion",
          "Required parameter ethConsensusVersion was null or undefined when calling publishBlockV2."
        );
      }
      const localVarPath = `/eth/v2/beacon/blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (broadcastValidation !== undefined) {
        localVarQueryParameter["broadcast_validation"] = broadcastValidation;
      }

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishBlockV2: async (
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishBlockV2."
        );
      }
      // verify required parameter 'ethConsensusVersion' is not null or undefined
      if (ethConsensusVersion === null || ethConsensusVersion === undefined) {
        throw new RequiredError(
          "ethConsensusVersion",
          "Required parameter ethConsensusVersion was null or undefined when calling publishBlockV2."
        );
      }
      const localVarPath = `/eth/v2/beacon/blocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (broadcastValidation !== undefined) {
        localVarQueryParameter["broadcast_validation"] = broadcastValidation;
      }

      if (ethConsensusVersion !== undefined && ethConsensusVersion !== null) {
        localVarHeaderParameter["Eth-Consensus-Version"] = String(
          JSON.stringify(ethConsensusVersion)
        );
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Publish multiple signed sync committee contribution and proofs
     * @summary Publish multiple contribution and proofs
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishContributionAndProofs: async (
      body: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling publishContributionAndProofs."
        );
      }
      const localVarPath = `/eth/v1/validator/contribution_and_proofs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Submits Attestation objects to the node.  Each attestation in the request body is processed individually.  If an attestation is validated successfully the node MUST publish that attestation on the appropriate subnet.  If one or more attestations fail validation the node MUST return a 400 error with details of which attestations have failed, and why.
     * @summary Submit Attestation objects to node
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitPoolAttestations: async (
      body: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling submitPoolAttestations."
        );
      }
      const localVarPath = `/eth/v1/beacon/pool/attestations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Submits sync committee signature objects to the node.  Sync committee signatures are not present in phase0, but are required for Altair networks.  If a sync committee signature is validated successfully the node MUST publish that sync committee signature on all applicable subnets.  If one or more sync committee signatures fail validation the node MUST return a 400 error with details of which sync committee signatures have failed, and why.
     * @summary Submit sync committee signatures to node
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitPoolSyncCommitteeSignatures: async (
      body: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling submitPoolSyncCommitteeSignatures."
        );
      }
      const localVarPath = `/eth/v1/beacon/pool/sync_committees`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, "https://example.com");
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ValidatorRequiredApiApi - functional programming interface
 * @export
 */
export const ValidatorRequiredApiApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     * Provides endpoint to subscribe to beacon node Server-Sent-Events stream. Consumers should use [eventsource](https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface) implementation to listen on those events.  Servers _may_ send SSE comments beginning with `:` for any purpose, including to keep the event stream connection alive in the presence of proxy servers.
     * @summary Subscribe to beacon node events
     * @param {any} topics Event types to subscribe to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eventstream(
      topics: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).eventstream(topics, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Aggregates all attestations matching given attestation data root and slot.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the aggregated attestation attests to a block that has not been fully verified by an execution engine).  A 404 error must be returned if no attestation is available for the requested `attestation_data_root`.
     * @summary Get aggregated attestation
     * @param {any} attestationDataRoot HashTreeRoot of AttestationData that validator wants aggregated
     * @param {any} slot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAggregatedAttestation(
      attestationDataRoot: any,
      slot: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetAggregatedAttestationResponse>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).getAggregatedAttestation(attestationDataRoot, slot, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Requests the beacon node to provide a set of attestation duties, which should be performed by validators, for a particular epoch. Duties should only need to be checked once per epoch, however a chain reorganization (of > MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.previous_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) + 1 == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1) - 1)` or the genesis block root in the case of underflow.
     * @summary Get attester duties
     * @param {any} body An array of the validator indices for which to obtain the duties.
     * @param {any} epoch Should only be allowed 1 epoch ahead
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAttesterDuties(
      body: any,
      epoch: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetAttesterDutiesResponse>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).getAttesterDuties(body, epoch, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieve details of the chain's genesis which can be used to identify chain.
     * @summary Retrieve details of the chain's genesis.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGenesis(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetGenesisResponse>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).getGenesis(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1)` or the genesis block root in the case of underflow.
     * @summary Get block proposers duties
     * @param {any} epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProposerDuties(
      epoch: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetProposerDutiesResponse>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).getProposerDuties(epoch, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieve specification configuration used on this node.  The configuration should include:   - Constants for all hard forks known by the beacon node, for example the [phase 0](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#constants) and [altair](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/beacon-chain.md#constants) values   - Presets for all hard forks supplied to the beacon node, for example the [phase 0](https://github.com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/phase0.yaml) and [altair](https://github.com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/altair.yaml) values   - Configuration for the beacon node, for example the [mainnet](https://github.com/ethereum/consensus-specs/blob/v1.3.0/configs/mainnet.yaml) values  Values are returned with following format:   - any value starting with 0x in the spec is returned as a hex string   - numeric values are returned as a quoted integer
     * @summary Get spec params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSpec(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetSpecResponse>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).getSpec(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#fork) object for state with given 'stateId'.
     * @summary Get Fork object for requested state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateFork(
      stateId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetStateForkResponse>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).getStateFork(stateId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns validator specified by state and id or public key along with status and balance.
     * @summary Get validator from state by id
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} validatorId Either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateValidator(
      stateId: any,
      validatorId: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetStateValidatorResponse>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).getStateValidator(stateId, validatorId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Requests the beacon node to provide a set of sync committee duties for a particular epoch.
     * @summary Get sync committee duties
     * @param {any} body An array of the validator indices for which to obtain the duties.
     * @param {any} epoch epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD &lt;&#x3D; current_epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD + 1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSyncCommitteeDuties(
      body: any,
      epoch: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetSyncCommitteeDutiesResponse>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).getSyncCommitteeDuties(body, epoch, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to.
     * @summary Get node syncing status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSyncingStatus(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<GetSyncingStatusResponse>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).getSyncingStatus(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * After beacon node receives this request, search using discv5 for peers related to this subnet and replace current peers with those ones if necessary If validator `is_aggregator`, beacon node must: - announce subnet topic subscription on gossipsub - aggregate attestations received on that subnet
     * @summary Signal beacon node to prepare for a committee subnet
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async prepareBeaconCommitteeSubnet(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).prepareBeaconCommitteeSubnet(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Prepares the beacon node for potential proposers by supplying information required when proposing blocks for the given validators.  The information supplied for each validator index will persist through the epoch in which the call is submitted and for a further two epochs after that, or until the beacon node restarts.  It is expected that validator clients will send this information periodically, for example each epoch, to ensure beacon nodes have correct and timely fee recipient information.  Note that there is no guarantee that the beacon node will use the supplied fee recipient when creating a block proposal, so on receipt of a proposed block the validator should confirm that it finds the fee recipient within the block acceptable before signing it.  Also note that requests containing currently inactive or unknown validator indices will be accepted, as they may become active at a later epoch.
     * @summary Provide beacon node with proposals for the given validators.
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async prepareBeaconProposer(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).prepareBeaconProposer(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Subscribe to a number of sync committee subnets  Sync committees are not present in phase0, but are required for Altair networks.  Subscribing to sync committee subnets is an action performed by VC to enable network participation in Altair networks, and only required if the VC has an active validator in an active sync committee.
     * @summary Subscribe to sync committee subnets
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async prepareSyncCommitteeSubnets(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).prepareSyncCommitteeSubnets(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Requests that the beacon node produce an AttestationData.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the attestation attests to a block that has not been fully verified by an execution engine).
     * @summary Produce an attestation data
     * @param {any} slot The slot for which an attestation data should be created.
     * @param {any} committeeIndex The committee index for which an attestation data should be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async produceAttestationData(
      slot: any,
      committeeIndex: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<ProduceAttestationDataResponse>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).produceAttestationData(slot, committeeIndex, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Requests a beacon node to produce a valid blinded block, which can then be signed by a validator.  A blinded block is a block with only a transactions root, rather than a full transactions list.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.  Before Bellatrix, this endpoint will return a `BeaconBlock`.
     * @summary Produce a new blinded block, without signature.
     * @param {any} slot The slot for which the block should be proposed.
     * @param {any} randaoReveal The validator&#x27;s randao reveal value.
     * @param {any} [graffiti] Arbitrary data validator wants to include in block.
     * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async produceBlindedBlock(
      slot: any,
      randaoReveal: any,
      graffiti?: any,
      skipRandaoVerification?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<ProduceBlindedBlockResponse>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).produceBlindedBlock(
        slot,
        randaoReveal,
        graffiti,
        skipRandaoVerification,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Requests a beacon node to produce a valid block, which can then be signed by a validator.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.
     * @summary Produce a new block, without signature.
     * @param {any} slot The slot for which the block should be proposed.
     * @param {any} randaoReveal The validator&#x27;s randao reveal value.
     * @param {any} [graffiti] Arbitrary data validator wants to include in block.
     * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async produceBlockV2(
      slot: any,
      randaoReveal: any,
      graffiti?: any,
      skipRandaoVerification?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<ProduceBlockV2Response>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).produceBlockV2(
        slot,
        randaoReveal,
        graffiti,
        skipRandaoVerification,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Requests a beacon node to produce a valid block, which can then be signed by a validator. The returned block may be blinded or unblinded, depending on the current state of the network as decided by the execution and beacon nodes.  The beacon node must return an unblinded block if it obtains the execution payload from its paired execution node. It must only return a blinded block if it obtains the execution payload header from an MEV relay.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.
     * @summary Produce a new block, without signature.
     * @param {any} slot The slot for which the block should be proposed.
     * @param {any} randaoReveal The validator&#x27;s randao reveal value.
     * @param {any} [graffiti] Arbitrary data validator wants to include in block.
     * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value.
     * @param {any} [builderBoostFactor] Percentage multiplier to apply to the builder&#x27;s payload value when choosing between a builder payload header and payload from the paired execution node. This parameter is only relevant if the beacon node is connected to a builder, deems it safe to produce a builder payload, and receives valid responses from both the builder endpoint _and_ the paired execution node. When these preconditions are met, the server MUST act as follows:  * if &#x60;exec_node_payload_value &gt;&#x3D; builder_boost_factor * (builder_payload_value // 100)&#x60;,   then return a full (unblinded) block containing the execution node payload. * otherwise, return a blinded block containing the builder payload header.  Servers must support the following values of the boost factor which encode common preferences:  * &#x60;builder_boost_factor&#x3D;0&#x60;: prefer the execution node payload unless an error makes it   unviable. * &#x60;builder_boost_factor&#x3D;100&#x60;: default profit maximization mode; choose whichever   payload pays more. * &#x60;builder_boost_factor&#x3D;2**64 - 1&#x60;: prefer the builder payload unless an error or   beacon node health check makes it unviable.  Servers should use saturating arithmetic or another technique to ensure that large values of the &#x60;builder_boost_factor&#x60; do not trigger overflows or errors. If this parameter is provided and the beacon node is not configured with a builder then the beacon node MUST respond with a full block, which the caller can choose to reject if it wishes. If this parameter is **not** provided then it should be treated as having the default value of 100. If the value is provided but out of range for a 64-bit unsigned integer, then an error response with status code 400 MUST be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async produceBlockV3(
      slot: any,
      randaoReveal: any,
      graffiti?: any,
      skipRandaoVerification?: any,
      builderBoostFactor?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<ProduceBlockV3Response>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).produceBlockV3(
        slot,
        randaoReveal,
        graffiti,
        skipRandaoVerification,
        builderBoostFactor,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Requests that the beacon node produce a sync committee contribution.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the sync committee contribution refers to a block that has not been fully verified by an execution engine).
     * @summary Produce a sync committee contribution
     * @param {any} slot The slot for which a sync committee contribution should be created.
     * @param {any} subcommitteeIndex the subcommittee index for which to produce the contribution.
     * @param {any} beaconBlockRoot the block root for which to produce the contribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async produceSyncCommitteeContribution(
      slot: any,
      subcommitteeIndex: any,
      beaconBlockRoot: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => Promise<AxiosResponse<ProduceSyncCommitteeContributionResponse>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).produceSyncCommitteeContribution(
        slot,
        subcommitteeIndex,
        beaconBlockRoot,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
     * @summary Publish multiple aggregate and proofs
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishAggregateAndProofs(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).publishAggregateAndProofs(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlindedBlock(
      body: any,
      ethConsensusVersion?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).publishBlindedBlock(body, ethConsensusVersion, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlindedBlock(
      body: any,
      ethConsensusVersion?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).publishBlindedBlock(body, ethConsensusVersion, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlindedBlockV2(
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).publishBlindedBlockV2(
        body,
        ethConsensusVersion,
        broadcastValidation,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlindedBlockV2(
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).publishBlindedBlockV2(
        body,
        ethConsensusVersion,
        broadcastValidation,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlock(
      body: any,
      ethConsensusVersion?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).publishBlock(body, ethConsensusVersion, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlock(
      body: any,
      ethConsensusVersion?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).publishBlock(body, ethConsensusVersion, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlockV2(
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).publishBlockV2(body, ethConsensusVersion, broadcastValidation, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlockV2(
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).publishBlockV2(body, ethConsensusVersion, broadcastValidation, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Publish multiple signed sync committee contribution and proofs
     * @summary Publish multiple contribution and proofs
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishContributionAndProofs(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).publishContributionAndProofs(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Submits Attestation objects to the node.  Each attestation in the request body is processed individually.  If an attestation is validated successfully the node MUST publish that attestation on the appropriate subnet.  If one or more attestations fail validation the node MUST return a 400 error with details of which attestations have failed, and why.
     * @summary Submit Attestation objects to node
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolAttestations(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).submitPoolAttestations(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Submits sync committee signature objects to the node.  Sync committee signatures are not present in phase0, but are required for Altair networks.  If a sync committee signature is validated successfully the node MUST publish that sync committee signature on all applicable subnets.  If one or more sync committee signatures fail validation the node MUST return a 400 error with details of which sync committee signatures have failed, and why.
     * @summary Submit sync committee signatures to node
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolSyncCommitteeSignatures(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>
    > {
      const localVarAxiosArgs = await ValidatorRequiredApiApiAxiosParamCreator(
        configuration
      ).submitPoolSyncCommitteeSignatures(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ValidatorRequiredApiApi - factory interface
 * @export
 */
export const ValidatorRequiredApiApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Provides endpoint to subscribe to beacon node Server-Sent-Events stream. Consumers should use [eventsource](https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface) implementation to listen on those events.  Servers _may_ send SSE comments beginning with `:` for any purpose, including to keep the event stream connection alive in the presence of proxy servers.
     * @summary Subscribe to beacon node events
     * @param {any} topics Event types to subscribe to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eventstream(
      topics: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<any>> {
      return ValidatorRequiredApiApiFp(configuration)
        .eventstream(topics, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Aggregates all attestations matching given attestation data root and slot.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the aggregated attestation attests to a block that has not been fully verified by an execution engine).  A 404 error must be returned if no attestation is available for the requested `attestation_data_root`.
     * @summary Get aggregated attestation
     * @param {any} attestationDataRoot HashTreeRoot of AttestationData that validator wants aggregated
     * @param {any} slot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAggregatedAttestation(
      attestationDataRoot: any,
      slot: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetAggregatedAttestationResponse>> {
      return ValidatorRequiredApiApiFp(configuration)
        .getAggregatedAttestation(attestationDataRoot, slot, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests the beacon node to provide a set of attestation duties, which should be performed by validators, for a particular epoch. Duties should only need to be checked once per epoch, however a chain reorganization (of > MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.previous_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) + 1 == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1) - 1)` or the genesis block root in the case of underflow.
     * @summary Get attester duties
     * @param {any} body An array of the validator indices for which to obtain the duties.
     * @param {any} epoch Should only be allowed 1 epoch ahead
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAttesterDuties(
      body: any,
      epoch: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetAttesterDutiesResponse>> {
      return ValidatorRequiredApiApiFp(configuration)
        .getAttesterDuties(body, epoch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve details of the chain's genesis which can be used to identify chain.
     * @summary Retrieve details of the chain's genesis.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGenesis(
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetGenesisResponse>> {
      return ValidatorRequiredApiApiFp(configuration)
        .getGenesis(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1)` or the genesis block root in the case of underflow.
     * @summary Get block proposers duties
     * @param {any} epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProposerDuties(
      epoch: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetProposerDutiesResponse>> {
      return ValidatorRequiredApiApiFp(configuration)
        .getProposerDuties(epoch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve specification configuration used on this node.  The configuration should include:   - Constants for all hard forks known by the beacon node, for example the [phase 0](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#constants) and [altair](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/beacon-chain.md#constants) values   - Presets for all hard forks supplied to the beacon node, for example the [phase 0](https://github.com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/phase0.yaml) and [altair](https://github.com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/altair.yaml) values   - Configuration for the beacon node, for example the [mainnet](https://github.com/ethereum/consensus-specs/blob/v1.3.0/configs/mainnet.yaml) values  Values are returned with following format:   - any value starting with 0x in the spec is returned as a hex string   - numeric values are returned as a quoted integer
     * @summary Get spec params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSpec(
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetSpecResponse>> {
      return ValidatorRequiredApiApiFp(configuration)
        .getSpec(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#fork) object for state with given 'stateId'.
     * @summary Get Fork object for requested state
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateFork(
      stateId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetStateForkResponse>> {
      return ValidatorRequiredApiApiFp(configuration)
        .getStateFork(stateId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns validator specified by state and id or public key along with status and balance.
     * @summary Get validator from state by id
     * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param {any} validatorId Either hex encoded public key (any bytes48 with 0x prefix) or validator index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStateValidator(
      stateId: any,
      validatorId: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetStateValidatorResponse>> {
      return ValidatorRequiredApiApiFp(configuration)
        .getStateValidator(stateId, validatorId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests the beacon node to provide a set of sync committee duties for a particular epoch.
     * @summary Get sync committee duties
     * @param {any} body An array of the validator indices for which to obtain the duties.
     * @param {any} epoch epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD &lt;&#x3D; current_epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD + 1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSyncCommitteeDuties(
      body: any,
      epoch: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetSyncCommitteeDutiesResponse>> {
      return ValidatorRequiredApiApiFp(configuration)
        .getSyncCommitteeDuties(body, epoch, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to.
     * @summary Get node syncing status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSyncingStatus(
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<GetSyncingStatusResponse>> {
      return ValidatorRequiredApiApiFp(configuration)
        .getSyncingStatus(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * After beacon node receives this request, search using discv5 for peers related to this subnet and replace current peers with those ones if necessary If validator `is_aggregator`, beacon node must: - announce subnet topic subscription on gossipsub - aggregate attestations received on that subnet
     * @summary Signal beacon node to prepare for a committee subnet
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async prepareBeaconCommitteeSubnet(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .prepareBeaconCommitteeSubnet(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Prepares the beacon node for potential proposers by supplying information required when proposing blocks for the given validators.  The information supplied for each validator index will persist through the epoch in which the call is submitted and for a further two epochs after that, or until the beacon node restarts.  It is expected that validator clients will send this information periodically, for example each epoch, to ensure beacon nodes have correct and timely fee recipient information.  Note that there is no guarantee that the beacon node will use the supplied fee recipient when creating a block proposal, so on receipt of a proposed block the validator should confirm that it finds the fee recipient within the block acceptable before signing it.  Also note that requests containing currently inactive or unknown validator indices will be accepted, as they may become active at a later epoch.
     * @summary Provide beacon node with proposals for the given validators.
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async prepareBeaconProposer(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .prepareBeaconProposer(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Subscribe to a number of sync committee subnets  Sync committees are not present in phase0, but are required for Altair networks.  Subscribing to sync committee subnets is an action performed by VC to enable network participation in Altair networks, and only required if the VC has an active validator in an active sync committee.
     * @summary Subscribe to sync committee subnets
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async prepareSyncCommitteeSubnets(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .prepareSyncCommitteeSubnets(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests that the beacon node produce an AttestationData.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the attestation attests to a block that has not been fully verified by an execution engine).
     * @summary Produce an attestation data
     * @param {any} slot The slot for which an attestation data should be created.
     * @param {any} committeeIndex The committee index for which an attestation data should be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async produceAttestationData(
      slot: any,
      committeeIndex: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<ProduceAttestationDataResponse>> {
      return ValidatorRequiredApiApiFp(configuration)
        .produceAttestationData(slot, committeeIndex, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests a beacon node to produce a valid blinded block, which can then be signed by a validator.  A blinded block is a block with only a transactions root, rather than a full transactions list.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.  Before Bellatrix, this endpoint will return a `BeaconBlock`.
     * @summary Produce a new blinded block, without signature.
     * @param {any} slot The slot for which the block should be proposed.
     * @param {any} randaoReveal The validator&#x27;s randao reveal value.
     * @param {any} [graffiti] Arbitrary data validator wants to include in block.
     * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async produceBlindedBlock(
      slot: any,
      randaoReveal: any,
      graffiti?: any,
      skipRandaoVerification?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<ProduceBlindedBlockResponse>> {
      return ValidatorRequiredApiApiFp(configuration)
        .produceBlindedBlock(
          slot,
          randaoReveal,
          graffiti,
          skipRandaoVerification,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests a beacon node to produce a valid block, which can then be signed by a validator.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.
     * @summary Produce a new block, without signature.
     * @param {any} slot The slot for which the block should be proposed.
     * @param {any} randaoReveal The validator&#x27;s randao reveal value.
     * @param {any} [graffiti] Arbitrary data validator wants to include in block.
     * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async produceBlockV2(
      slot: any,
      randaoReveal: any,
      graffiti?: any,
      skipRandaoVerification?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<ProduceBlockV2Response>> {
      return ValidatorRequiredApiApiFp(configuration)
        .produceBlockV2(
          slot,
          randaoReveal,
          graffiti,
          skipRandaoVerification,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests a beacon node to produce a valid block, which can then be signed by a validator. The returned block may be blinded or unblinded, depending on the current state of the network as decided by the execution and beacon nodes.  The beacon node must return an unblinded block if it obtains the execution payload from its paired execution node. It must only return a blinded block if it obtains the execution payload header from an MEV relay.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.
     * @summary Produce a new block, without signature.
     * @param {any} slot The slot for which the block should be proposed.
     * @param {any} randaoReveal The validator&#x27;s randao reveal value.
     * @param {any} [graffiti] Arbitrary data validator wants to include in block.
     * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value.
     * @param {any} [builderBoostFactor] Percentage multiplier to apply to the builder&#x27;s payload value when choosing between a builder payload header and payload from the paired execution node. This parameter is only relevant if the beacon node is connected to a builder, deems it safe to produce a builder payload, and receives valid responses from both the builder endpoint _and_ the paired execution node. When these preconditions are met, the server MUST act as follows:  * if &#x60;exec_node_payload_value &gt;&#x3D; builder_boost_factor * (builder_payload_value // 100)&#x60;,   then return a full (unblinded) block containing the execution node payload. * otherwise, return a blinded block containing the builder payload header.  Servers must support the following values of the boost factor which encode common preferences:  * &#x60;builder_boost_factor&#x3D;0&#x60;: prefer the execution node payload unless an error makes it   unviable. * &#x60;builder_boost_factor&#x3D;100&#x60;: default profit maximization mode; choose whichever   payload pays more. * &#x60;builder_boost_factor&#x3D;2**64 - 1&#x60;: prefer the builder payload unless an error or   beacon node health check makes it unviable.  Servers should use saturating arithmetic or another technique to ensure that large values of the &#x60;builder_boost_factor&#x60; do not trigger overflows or errors. If this parameter is provided and the beacon node is not configured with a builder then the beacon node MUST respond with a full block, which the caller can choose to reject if it wishes. If this parameter is **not** provided then it should be treated as having the default value of 100. If the value is provided but out of range for a 64-bit unsigned integer, then an error response with status code 400 MUST be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async produceBlockV3(
      slot: any,
      randaoReveal: any,
      graffiti?: any,
      skipRandaoVerification?: any,
      builderBoostFactor?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<ProduceBlockV3Response>> {
      return ValidatorRequiredApiApiFp(configuration)
        .produceBlockV3(
          slot,
          randaoReveal,
          graffiti,
          skipRandaoVerification,
          builderBoostFactor,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests that the beacon node produce a sync committee contribution.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the sync committee contribution refers to a block that has not been fully verified by an execution engine).
     * @summary Produce a sync committee contribution
     * @param {any} slot The slot for which a sync committee contribution should be created.
     * @param {any} subcommitteeIndex the subcommittee index for which to produce the contribution.
     * @param {any} beaconBlockRoot the block root for which to produce the contribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async produceSyncCommitteeContribution(
      slot: any,
      subcommitteeIndex: any,
      beaconBlockRoot: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<ProduceSyncCommitteeContributionResponse>> {
      return ValidatorRequiredApiApiFp(configuration)
        .produceSyncCommitteeContribution(
          slot,
          subcommitteeIndex,
          beaconBlockRoot,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
     * @summary Publish multiple aggregate and proofs
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishAggregateAndProofs(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .publishAggregateAndProofs(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlindedBlock(
      body: any,
      ethConsensusVersion?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .publishBlindedBlock(body, ethConsensusVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlindedBlock(
      body: any,
      ethConsensusVersion?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .publishBlindedBlock(body, ethConsensusVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlindedBlockV2(
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .publishBlindedBlockV2(
          body,
          ethConsensusVersion,
          broadcastValidation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlindedBlockV2(
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .publishBlindedBlockV2(
          body,
          ethConsensusVersion,
          broadcastValidation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlock(
      body: any,
      ethConsensusVersion?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .publishBlock(body, ethConsensusVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlock(
      body: any,
      ethConsensusVersion?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .publishBlock(body, ethConsensusVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlockV2(
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .publishBlockV2(body, ethConsensusVersion, broadcastValidation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
     * @summary Publish a signed block.
     * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @param {any} ethConsensusVersion Version of the block being submitted.
     * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishBlockV2(
      body: any,
      ethConsensusVersion: any,
      broadcastValidation?: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .publishBlockV2(body, ethConsensusVersion, broadcastValidation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Publish multiple signed sync committee contribution and proofs
     * @summary Publish multiple contribution and proofs
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishContributionAndProofs(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .publishContributionAndProofs(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Submits Attestation objects to the node.  Each attestation in the request body is processed individually.  If an attestation is validated successfully the node MUST publish that attestation on the appropriate subnet.  If one or more attestations fail validation the node MUST return a 400 error with details of which attestations have failed, and why.
     * @summary Submit Attestation objects to node
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolAttestations(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .submitPoolAttestations(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Submits sync committee signature objects to the node.  Sync committee signatures are not present in phase0, but are required for Altair networks.  If a sync committee signature is validated successfully the node MUST publish that sync committee signature on all applicable subnets.  If one or more sync committee signatures fail validation the node MUST return a 400 error with details of which sync committee signatures have failed, and why.
     * @summary Submit sync committee signatures to node
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitPoolSyncCommitteeSignatures(
      body: any,
      options?: AxiosRequestConfig
    ): Promise<AxiosResponse<void>> {
      return ValidatorRequiredApiApiFp(configuration)
        .submitPoolSyncCommitteeSignatures(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ValidatorRequiredApiApi - object-oriented interface
 * @export
 * @class ValidatorRequiredApiApi
 * @extends {BaseAPI}
 */
export class ValidatorRequiredApiApi extends BaseAPI {
  /**
   * Provides endpoint to subscribe to beacon node Server-Sent-Events stream. Consumers should use [eventsource](https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface) implementation to listen on those events.  Servers _may_ send SSE comments beginning with `:` for any purpose, including to keep the event stream connection alive in the presence of proxy servers.
   * @summary Subscribe to beacon node events
   * @param {any} topics Event types to subscribe to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async eventstream(
    topics: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<any>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .eventstream(topics, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Aggregates all attestations matching given attestation data root and slot.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the aggregated attestation attests to a block that has not been fully verified by an execution engine).  A 404 error must be returned if no attestation is available for the requested `attestation_data_root`.
   * @summary Get aggregated attestation
   * @param {any} attestationDataRoot HashTreeRoot of AttestationData that validator wants aggregated
   * @param {any} slot
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async getAggregatedAttestation(
    attestationDataRoot: any,
    slot: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetAggregatedAttestationResponse>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .getAggregatedAttestation(attestationDataRoot, slot, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Requests the beacon node to provide a set of attestation duties, which should be performed by validators, for a particular epoch. Duties should only need to be checked once per epoch, however a chain reorganization (of > MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.previous_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) + 1 == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1) - 1)` or the genesis block root in the case of underflow.
   * @summary Get attester duties
   * @param {any} body An array of the validator indices for which to obtain the duties.
   * @param {any} epoch Should only be allowed 1 epoch ahead
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async getAttesterDuties(
    body: any,
    epoch: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetAttesterDutiesResponse>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .getAttesterDuties(body, epoch, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieve details of the chain's genesis which can be used to identify chain.
   * @summary Retrieve details of the chain's genesis.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async getGenesis(
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetGenesisResponse>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .getGenesis(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1)` or the genesis block root in the case of underflow.
   * @summary Get block proposers duties
   * @param {any} epoch
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async getProposerDuties(
    epoch: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetProposerDutiesResponse>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .getProposerDuties(epoch, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieve specification configuration used on this node.  The configuration should include:   - Constants for all hard forks known by the beacon node, for example the [phase 0](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#constants) and [altair](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/beacon-chain.md#constants) values   - Presets for all hard forks supplied to the beacon node, for example the [phase 0](https://github.com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/phase0.yaml) and [altair](https://github.com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/altair.yaml) values   - Configuration for the beacon node, for example the [mainnet](https://github.com/ethereum/consensus-specs/blob/v1.3.0/configs/mainnet.yaml) values  Values are returned with following format:   - any value starting with 0x in the spec is returned as a hex string   - numeric values are returned as a quoted integer
   * @summary Get spec params.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async getSpec(
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetSpecResponse>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .getSpec(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#fork) object for state with given 'stateId'.
   * @summary Get Fork object for requested state
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async getStateFork(
    stateId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetStateForkResponse>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .getStateFork(stateId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns validator specified by state and id or public key along with status and balance.
   * @summary Get validator from state by id
   * @param {any} stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
   * @param {any} validatorId Either hex encoded public key (any bytes48 with 0x prefix) or validator index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async getStateValidator(
    stateId: any,
    validatorId: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetStateValidatorResponse>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .getStateValidator(stateId, validatorId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Requests the beacon node to provide a set of sync committee duties for a particular epoch.
   * @summary Get sync committee duties
   * @param {any} body An array of the validator indices for which to obtain the duties.
   * @param {any} epoch epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD &lt;&#x3D; current_epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD + 1
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async getSyncCommitteeDuties(
    body: any,
    epoch: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetSyncCommitteeDutiesResponse>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .getSyncCommitteeDuties(body, epoch, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to.
   * @summary Get node syncing status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async getSyncingStatus(
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<GetSyncingStatusResponse>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .getSyncingStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * After beacon node receives this request, search using discv5 for peers related to this subnet and replace current peers with those ones if necessary If validator `is_aggregator`, beacon node must: - announce subnet topic subscription on gossipsub - aggregate attestations received on that subnet
   * @summary Signal beacon node to prepare for a committee subnet
   * @param {any} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async prepareBeaconCommitteeSubnet(
    body: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .prepareBeaconCommitteeSubnet(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Prepares the beacon node for potential proposers by supplying information required when proposing blocks for the given validators.  The information supplied for each validator index will persist through the epoch in which the call is submitted and for a further two epochs after that, or until the beacon node restarts.  It is expected that validator clients will send this information periodically, for example each epoch, to ensure beacon nodes have correct and timely fee recipient information.  Note that there is no guarantee that the beacon node will use the supplied fee recipient when creating a block proposal, so on receipt of a proposed block the validator should confirm that it finds the fee recipient within the block acceptable before signing it.  Also note that requests containing currently inactive or unknown validator indices will be accepted, as they may become active at a later epoch.
   * @summary Provide beacon node with proposals for the given validators.
   * @param {any} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async prepareBeaconProposer(
    body: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .prepareBeaconProposer(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Subscribe to a number of sync committee subnets  Sync committees are not present in phase0, but are required for Altair networks.  Subscribing to sync committee subnets is an action performed by VC to enable network participation in Altair networks, and only required if the VC has an active validator in an active sync committee.
   * @summary Subscribe to sync committee subnets
   * @param {any} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async prepareSyncCommitteeSubnets(
    body: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .prepareSyncCommitteeSubnets(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Requests that the beacon node produce an AttestationData.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the attestation attests to a block that has not been fully verified by an execution engine).
   * @summary Produce an attestation data
   * @param {any} slot The slot for which an attestation data should be created.
   * @param {any} committeeIndex The committee index for which an attestation data should be created.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async produceAttestationData(
    slot: any,
    committeeIndex: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<ProduceAttestationDataResponse>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .produceAttestationData(slot, committeeIndex, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Requests a beacon node to produce a valid blinded block, which can then be signed by a validator.  A blinded block is a block with only a transactions root, rather than a full transactions list.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.  Before Bellatrix, this endpoint will return a `BeaconBlock`.
   * @summary Produce a new blinded block, without signature.
   * @param {any} slot The slot for which the block should be proposed.
   * @param {any} randaoReveal The validator&#x27;s randao reveal value.
   * @param {any} [graffiti] Arbitrary data validator wants to include in block.
   * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async produceBlindedBlock(
    slot: any,
    randaoReveal: any,
    graffiti?: any,
    skipRandaoVerification?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<ProduceBlindedBlockResponse>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .produceBlindedBlock(
        slot,
        randaoReveal,
        graffiti,
        skipRandaoVerification,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Requests a beacon node to produce a valid block, which can then be signed by a validator.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.
   * @summary Produce a new block, without signature.
   * @param {any} slot The slot for which the block should be proposed.
   * @param {any} randaoReveal The validator&#x27;s randao reveal value.
   * @param {any} [graffiti] Arbitrary data validator wants to include in block.
   * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async produceBlockV2(
    slot: any,
    randaoReveal: any,
    graffiti?: any,
    skipRandaoVerification?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<ProduceBlockV2Response>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .produceBlockV2(
        slot,
        randaoReveal,
        graffiti,
        skipRandaoVerification,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Requests a beacon node to produce a valid block, which can then be signed by a validator. The returned block may be blinded or unblinded, depending on the current state of the network as decided by the execution and beacon nodes.  The beacon node must return an unblinded block if it obtains the execution payload from its paired execution node. It must only return a blinded block if it obtains the execution payload header from an MEV relay.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.
   * @summary Produce a new block, without signature.
   * @param {any} slot The slot for which the block should be proposed.
   * @param {any} randaoReveal The validator&#x27;s randao reveal value.
   * @param {any} [graffiti] Arbitrary data validator wants to include in block.
   * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value.
   * @param {any} [builderBoostFactor] Percentage multiplier to apply to the builder&#x27;s payload value when choosing between a builder payload header and payload from the paired execution node. This parameter is only relevant if the beacon node is connected to a builder, deems it safe to produce a builder payload, and receives valid responses from both the builder endpoint _and_ the paired execution node. When these preconditions are met, the server MUST act as follows:  * if &#x60;exec_node_payload_value &gt;&#x3D; builder_boost_factor * (builder_payload_value // 100)&#x60;,   then return a full (unblinded) block containing the execution node payload. * otherwise, return a blinded block containing the builder payload header.  Servers must support the following values of the boost factor which encode common preferences:  * &#x60;builder_boost_factor&#x3D;0&#x60;: prefer the execution node payload unless an error makes it   unviable. * &#x60;builder_boost_factor&#x3D;100&#x60;: default profit maximization mode; choose whichever   payload pays more. * &#x60;builder_boost_factor&#x3D;2**64 - 1&#x60;: prefer the builder payload unless an error or   beacon node health check makes it unviable.  Servers should use saturating arithmetic or another technique to ensure that large values of the &#x60;builder_boost_factor&#x60; do not trigger overflows or errors. If this parameter is provided and the beacon node is not configured with a builder then the beacon node MUST respond with a full block, which the caller can choose to reject if it wishes. If this parameter is **not** provided then it should be treated as having the default value of 100. If the value is provided but out of range for a 64-bit unsigned integer, then an error response with status code 400 MUST be returned.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async produceBlockV3(
    slot: any,
    randaoReveal: any,
    graffiti?: any,
    skipRandaoVerification?: any,
    builderBoostFactor?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<ProduceBlockV3Response>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .produceBlockV3(
        slot,
        randaoReveal,
        graffiti,
        skipRandaoVerification,
        builderBoostFactor,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Requests that the beacon node produce a sync committee contribution.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the sync committee contribution refers to a block that has not been fully verified by an execution engine).
   * @summary Produce a sync committee contribution
   * @param {any} slot The slot for which a sync committee contribution should be created.
   * @param {any} subcommitteeIndex the subcommittee index for which to produce the contribution.
   * @param {any} beaconBlockRoot the block root for which to produce the contribution.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async produceSyncCommitteeContribution(
    slot: any,
    subcommitteeIndex: any,
    beaconBlockRoot: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<ProduceSyncCommitteeContributionResponse>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .produceSyncCommitteeContribution(
        slot,
        subcommitteeIndex,
        beaconBlockRoot,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
   * @summary Publish multiple aggregate and proofs
   * @param {any} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async publishAggregateAndProofs(
    body: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .publishAggregateAndProofs(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async publishBlindedBlock(
    body: any,
    ethConsensusVersion?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .publishBlindedBlock(body, ethConsensusVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async publishBlindedBlock(
    body: any,
    ethConsensusVersion?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .publishBlindedBlock(body, ethConsensusVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} ethConsensusVersion Version of the block being submitted.
   * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async publishBlindedBlockV2(
    body: any,
    ethConsensusVersion: any,
    broadcastValidation?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .publishBlindedBlockV2(
        body,
        ethConsensusVersion,
        broadcastValidation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and publish a  `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of `transactions`. The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will accept  a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBlindedBeaconBlock&#x60; object composed of &#x60;BlindedBeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} ethConsensusVersion Version of the block being submitted.
   * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async publishBlindedBlockV2(
    body: any,
    ethConsensusVersion: any,
    broadcastValidation?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .publishBlindedBlockV2(
        body,
        ethConsensusVersion,
        broadcastValidation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async publishBlock(
    body: any,
    ethConsensusVersion?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .publishBlock(body, ethConsensusVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} [ethConsensusVersion] Version of the block being submitted, if using SSZ encoding.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async publishBlock(
    body: any,
    ethConsensusVersion?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .publishBlock(body, ethConsensusVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} ethConsensusVersion Version of the block being submitted.
   * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async publishBlockV2(
    body: any,
    ethConsensusVersion: any,
    broadcastValidation?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .publishBlockV2(body, ethConsensusVersion, broadcastValidation, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. A success response (20x) indicates that the block passed gossip validation and was successfully broadcast onto the network. The beacon node is also expected to integrate the block into the state, but may broadcast it before doing so, so as to aid timely delivery of the block. Should the block fail full validation, a separate success response code (202) is used to indicate that the block was successfully broadcast but failed integration. After Deneb, this additionally instructs the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the `broadcast_validation` query parameter.
   * @summary Publish a signed block.
   * @param {any} body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
   * @param {any} ethConsensusVersion Version of the block being submitted.
   * @param {any} [broadcastValidation] Level of validation that must be applied to a block before it is broadcast.  Possible values: - **&#x60;gossip&#x60;** (default): lightweight gossip checks only - **&#x60;consensus&#x60;**: full consensus checks, including validation of all signatures and   blocks fields _except_ for the execution payload transactions. - **&#x60;consensus_and_equivocation&#x60;**: the same as &#x60;consensus&#x60;, with an extra equivocation   check immediately before the block is broadcast. If the block is found to be an   equivocation it fails validation.  If the block fails the requested level of a validation a 400 status MUST be returned immediately and the block MUST NOT be broadcast to the network.  If validation succeeds, the block must still be fully verified before it is incorporated into the state and a 20x status is returned to the caller.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async publishBlockV2(
    body: any,
    ethConsensusVersion: any,
    broadcastValidation?: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .publishBlockV2(body, ethConsensusVersion, broadcastValidation, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Publish multiple signed sync committee contribution and proofs
   * @summary Publish multiple contribution and proofs
   * @param {any} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async publishContributionAndProofs(
    body: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .publishContributionAndProofs(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Submits Attestation objects to the node.  Each attestation in the request body is processed individually.  If an attestation is validated successfully the node MUST publish that attestation on the appropriate subnet.  If one or more attestations fail validation the node MUST return a 400 error with details of which attestations have failed, and why.
   * @summary Submit Attestation objects to node
   * @param {any} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async submitPoolAttestations(
    body: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .submitPoolAttestations(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Submits sync committee signature objects to the node.  Sync committee signatures are not present in phase0, but are required for Altair networks.  If a sync committee signature is validated successfully the node MUST publish that sync committee signature on all applicable subnets.  If one or more sync committee signatures fail validation the node MUST return a 400 error with details of which sync committee signatures have failed, and why.
   * @summary Submit sync committee signatures to node
   * @param {any} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorRequiredApiApi
   */
  public async submitPoolSyncCommitteeSignatures(
    body: any,
    options?: AxiosRequestConfig
  ): Promise<AxiosResponse<void>> {
    return ValidatorRequiredApiApiFp(this.configuration)
      .submitPoolSyncCommitteeSignatures(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
