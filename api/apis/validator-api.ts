/* tslint:disable */
/* eslint-disable */
/**
 * Eth Beacon Node API
 * API specification for the beacon node, which enables users to query and participate in Ethereum 2.0 phase 0 beacon chain.  All requests by default send and receive JSON, and as such should have either or both of the \"Content-Type: application/json\" and \"Accept: application/json\" headers.  In addition, some requests can return data in the SSZ format.  To indicate that SSZ data is required in response to a request the header \"Accept: application/octet-stream\" should be sent.  Note that only a subset of requests can respond with data in SSZ format; these are noted in each individual request.  API endpoints are individually versioned.  As such, there is no direct relationship between all v1 endpoints, all v2 endpoints, _etc._ and no such relationship should be inferred.  All JSON responses return the requested data under a `data` key in the top level of their response.  Additional metadata may or may not be present in other keys at the top level of the response, dependent on the endpoint.  The rules that require an increase in version number are as follows:    - no field that is listed in an endpoint shall be removed without an increase in the version number   - no field that is listed in an endpoint shall be altered in terms of format (_e.g._ from a string to an array) without an     increase in the version number  Note that it is possible for a field to be added to an endpoint's data or metadata without an increase in the version number. 
 *
 * OpenAPI spec version: v2.5.0 - Ethereum Proof-of-Stake Consensus Specification v1.4.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { BeaconCommitteeSelectionResponse } from '../models';
import { GetAggregatedAttestationResponse } from '../models';
import { GetAttesterDutiesResponse } from '../models';
import { GetProposerDutiesResponse } from '../models';
import { GetSyncCommitteeDutiesResponse } from '../models';
import { InlineResponse4001 } from '../models';
import { InlineResponse404 } from '../models';
import { InlineResponse501 } from '../models';
import { PostLivenessResponseBody } from '../models';
import { ProduceAttestationDataResponse } from '../models';
import { ProduceBlindedBlockResponse } from '../models';
import { ProduceBlockV2Response } from '../models';
import { ProduceBlockV3Response } from '../models';
import { ProduceSyncCommitteeContributionResponse } from '../models';
import { SyncCommitteeSelectionResponse } from '../models';
/**
 * ValidatorApi - axios parameter creator
 * @export
 */
export const ValidatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aggregates all attestations matching given attestation data root and slot.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the aggregated attestation attests to a block that has not been fully verified by an execution engine).  A 404 error must be returned if no attestation is available for the requested `attestation_data_root`. 
         * @summary Get aggregated attestation
         * @param {any} attestationDataRoot HashTreeRoot of AttestationData that validator wants aggregated
         * @param {any} slot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedAttestation: async (attestationDataRoot: any, slot: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attestationDataRoot' is not null or undefined
            if (attestationDataRoot === null || attestationDataRoot === undefined) {
                throw new RequiredError('attestationDataRoot','Required parameter attestationDataRoot was null or undefined when calling getAggregatedAttestation.');
            }
            // verify required parameter 'slot' is not null or undefined
            if (slot === null || slot === undefined) {
                throw new RequiredError('slot','Required parameter slot was null or undefined when calling getAggregatedAttestation.');
            }
            const localVarPath = `/eth/v1/validator/aggregate_attestation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (attestationDataRoot !== undefined) {
                localVarQueryParameter['attestation_data_root'] = attestationDataRoot;
            }

            if (slot !== undefined) {
                localVarQueryParameter['slot'] = slot;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests the beacon node to provide a set of attestation duties, which should be performed by validators, for a particular epoch. Duties should only need to be checked once per epoch, however a chain reorganization (of > MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.previous_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) + 1 == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1) - 1)` or the genesis block root in the case of underflow.
         * @summary Get attester duties
         * @param {any} body An array of the validator indices for which to obtain the duties.
         * @param {any} epoch Should only be allowed 1 epoch ahead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttesterDuties: async (body: any, epoch: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getAttesterDuties.');
            }
            // verify required parameter 'epoch' is not null or undefined
            if (epoch === null || epoch === undefined) {
                throw new RequiredError('epoch','Required parameter epoch was null or undefined when calling getAttesterDuties.');
            }
            const localVarPath = `/eth/v1/validator/duties/attester/{epoch}`
                .replace(`{${"epoch"}}`, encodeURIComponent(String(epoch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests the beacon node to indicate if a validator has been observed to be live in a given epoch. The beacon node might detect liveness by observing messages from the validator on the network, in the beacon chain, from its API or from any other source. A beacon node SHOULD support the current and previous epoch, however it MAY support earlier epoch. It is important to note that the values returned by the beacon node are not canonical; they are best-effort and based upon a subjective view of the network. A beacon node that was recently started or suffered a network partition may indicate that a validator is not live when it actually is.
         * @summary Indicates if a validator has been observed on the network
         * @param {any} body An array of the validator indices for which to detect liveness.
         * @param {any} epoch The epoch for which liveness is being queried
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveness: async (body: any, epoch: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getLiveness.');
            }
            // verify required parameter 'epoch' is not null or undefined
            if (epoch === null || epoch === undefined) {
                throw new RequiredError('epoch','Required parameter epoch was null or undefined when calling getLiveness.');
            }
            const localVarPath = `/eth/v1/validator/liveness/{epoch}`
                .replace(`{${"epoch"}}`, encodeURIComponent(String(epoch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1)` or the genesis block root in the case of underflow.
         * @summary Get block proposers duties
         * @param {any} epoch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProposerDuties: async (epoch: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'epoch' is not null or undefined
            if (epoch === null || epoch === undefined) {
                throw new RequiredError('epoch','Required parameter epoch was null or undefined when calling getProposerDuties.');
            }
            const localVarPath = `/eth/v1/validator/duties/proposer/{epoch}`
                .replace(`{${"epoch"}}`, encodeURIComponent(String(epoch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests the beacon node to provide a set of sync committee duties for a particular epoch.
         * @summary Get sync committee duties
         * @param {any} body An array of the validator indices for which to obtain the duties.
         * @param {any} epoch epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD &lt;&#x3D; current_epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD + 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncCommitteeDuties: async (body: any, epoch: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getSyncCommitteeDuties.');
            }
            // verify required parameter 'epoch' is not null or undefined
            if (epoch === null || epoch === undefined) {
                throw new RequiredError('epoch','Required parameter epoch was null or undefined when calling getSyncCommitteeDuties.');
            }
            const localVarPath = `/eth/v1/validator/duties/sync/{epoch}`
                .replace(`{${"epoch"}}`, encodeURIComponent(String(epoch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * After beacon node receives this request, search using discv5 for peers related to this subnet and replace current peers with those ones if necessary If validator `is_aggregator`, beacon node must: - announce subnet topic subscription on gossipsub - aggregate attestations received on that subnet 
         * @summary Signal beacon node to prepare for a committee subnet
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareBeaconCommitteeSubnet: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling prepareBeaconCommitteeSubnet.');
            }
            const localVarPath = `/eth/v1/validator/beacon_committee_subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Prepares the beacon node for potential proposers by supplying information required when proposing blocks for the given validators.  The information supplied for each validator index will persist through the epoch in which the call is submitted and for a further two epochs after that, or until the beacon node restarts.  It is expected that validator clients will send this information periodically, for example each epoch, to ensure beacon nodes have correct and timely fee recipient information.  Note that there is no guarantee that the beacon node will use the supplied fee recipient when creating a block proposal, so on receipt of a proposed block the validator should confirm that it finds the fee recipient within the block acceptable before signing it.  Also note that requests containing currently inactive or unknown validator indices will be accepted, as they may become active at a later epoch. 
         * @summary Provide beacon node with proposals for the given validators.
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareBeaconProposer: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling prepareBeaconProposer.');
            }
            const localVarPath = `/eth/v1/validator/prepare_beacon_proposer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscribe to a number of sync committee subnets  Sync committees are not present in phase0, but are required for Altair networks.  Subscribing to sync committee subnets is an action performed by VC to enable network participation in Altair networks, and only required if the VC has an active validator in an active sync committee. 
         * @summary Subscribe to sync committee subnets
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSyncCommitteeSubnets: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling prepareSyncCommitteeSubnets.');
            }
            const localVarPath = `/eth/v1/validator/sync_committee_subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests that the beacon node produce an AttestationData.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the attestation attests to a block that has not been fully verified by an execution engine). 
         * @summary Produce an attestation data
         * @param {any} slot The slot for which an attestation data should be created.
         * @param {any} committeeIndex The committee index for which an attestation data should be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        produceAttestationData: async (slot: any, committeeIndex: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slot' is not null or undefined
            if (slot === null || slot === undefined) {
                throw new RequiredError('slot','Required parameter slot was null or undefined when calling produceAttestationData.');
            }
            // verify required parameter 'committeeIndex' is not null or undefined
            if (committeeIndex === null || committeeIndex === undefined) {
                throw new RequiredError('committeeIndex','Required parameter committeeIndex was null or undefined when calling produceAttestationData.');
            }
            const localVarPath = `/eth/v1/validator/attestation_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (slot !== undefined) {
                localVarQueryParameter['slot'] = slot;
            }

            if (committeeIndex !== undefined) {
                localVarQueryParameter['committee_index'] = committeeIndex;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests a beacon node to produce a valid blinded block, which can then be signed by a validator.  A blinded block is a block with only a transactions root, rather than a full transactions list.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.  Before Bellatrix, this endpoint will return a `BeaconBlock`. 
         * @summary Produce a new blinded block, without signature.
         * @param {any} slot The slot for which the block should be proposed.
         * @param {any} randaoReveal The validator&#x27;s randao reveal value.
         * @param {any} [graffiti] Arbitrary data validator wants to include in block.
         * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        produceBlindedBlock: async (slot: any, randaoReveal: any, graffiti?: any, skipRandaoVerification?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slot' is not null or undefined
            if (slot === null || slot === undefined) {
                throw new RequiredError('slot','Required parameter slot was null or undefined when calling produceBlindedBlock.');
            }
            // verify required parameter 'randaoReveal' is not null or undefined
            if (randaoReveal === null || randaoReveal === undefined) {
                throw new RequiredError('randaoReveal','Required parameter randaoReveal was null or undefined when calling produceBlindedBlock.');
            }
            const localVarPath = `/eth/v1/validator/blinded_blocks/{slot}`
                .replace(`{${"slot"}}`, encodeURIComponent(String(slot)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (randaoReveal !== undefined) {
                localVarQueryParameter['randao_reveal'] = randaoReveal;
            }

            if (graffiti !== undefined) {
                localVarQueryParameter['graffiti'] = graffiti;
            }

            if (skipRandaoVerification !== undefined) {
                localVarQueryParameter['skip_randao_verification'] = skipRandaoVerification;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests a beacon node to produce a valid block, which can then be signed by a validator.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress. 
         * @summary Produce a new block, without signature.
         * @param {any} slot The slot for which the block should be proposed.
         * @param {any} randaoReveal The validator&#x27;s randao reveal value.
         * @param {any} [graffiti] Arbitrary data validator wants to include in block.
         * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        produceBlockV2: async (slot: any, randaoReveal: any, graffiti?: any, skipRandaoVerification?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slot' is not null or undefined
            if (slot === null || slot === undefined) {
                throw new RequiredError('slot','Required parameter slot was null or undefined when calling produceBlockV2.');
            }
            // verify required parameter 'randaoReveal' is not null or undefined
            if (randaoReveal === null || randaoReveal === undefined) {
                throw new RequiredError('randaoReveal','Required parameter randaoReveal was null or undefined when calling produceBlockV2.');
            }
            const localVarPath = `/eth/v2/validator/blocks/{slot}`
                .replace(`{${"slot"}}`, encodeURIComponent(String(slot)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (randaoReveal !== undefined) {
                localVarQueryParameter['randao_reveal'] = randaoReveal;
            }

            if (graffiti !== undefined) {
                localVarQueryParameter['graffiti'] = graffiti;
            }

            if (skipRandaoVerification !== undefined) {
                localVarQueryParameter['skip_randao_verification'] = skipRandaoVerification;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests a beacon node to produce a valid block, which can then be signed by a validator. The returned block may be blinded or unblinded, depending on the current state of the network as decided by the execution and beacon nodes.  The beacon node must return an unblinded block if it obtains the execution payload from its paired execution node. It must only return a blinded block if it obtains the execution payload header from an MEV relay.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress. 
         * @summary Produce a new block, without signature.
         * @param {any} slot The slot for which the block should be proposed.
         * @param {any} randaoReveal The validator&#x27;s randao reveal value.
         * @param {any} [graffiti] Arbitrary data validator wants to include in block.
         * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value. 
         * @param {any} [builderBoostFactor] Percentage multiplier to apply to the builder&#x27;s payload value when choosing between a builder payload header and payload from the paired execution node. This parameter is only relevant if the beacon node is connected to a builder, deems it safe to produce a builder payload, and receives valid responses from both the builder endpoint _and_ the paired execution node. When these preconditions are met, the server MUST act as follows:  * if &#x60;exec_node_payload_value &gt;&#x3D; builder_boost_factor * (builder_payload_value // 100)&#x60;,   then return a full (unblinded) block containing the execution node payload. * otherwise, return a blinded block containing the builder payload header.  Servers must support the following values of the boost factor which encode common preferences:  * &#x60;builder_boost_factor&#x3D;0&#x60;: prefer the execution node payload unless an error makes it   unviable. * &#x60;builder_boost_factor&#x3D;100&#x60;: default profit maximization mode; choose whichever   payload pays more. * &#x60;builder_boost_factor&#x3D;2**64 - 1&#x60;: prefer the builder payload unless an error or   beacon node health check makes it unviable.  Servers should use saturating arithmetic or another technique to ensure that large values of the &#x60;builder_boost_factor&#x60; do not trigger overflows or errors. If this parameter is provided and the beacon node is not configured with a builder then the beacon node MUST respond with a full block, which the caller can choose to reject if it wishes. If this parameter is **not** provided then it should be treated as having the default value of 100. If the value is provided but out of range for a 64-bit unsigned integer, then an error response with status code 400 MUST be returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        produceBlockV3: async (slot: any, randaoReveal: any, graffiti?: any, skipRandaoVerification?: any, builderBoostFactor?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slot' is not null or undefined
            if (slot === null || slot === undefined) {
                throw new RequiredError('slot','Required parameter slot was null or undefined when calling produceBlockV3.');
            }
            // verify required parameter 'randaoReveal' is not null or undefined
            if (randaoReveal === null || randaoReveal === undefined) {
                throw new RequiredError('randaoReveal','Required parameter randaoReveal was null or undefined when calling produceBlockV3.');
            }
            const localVarPath = `/eth/v3/validator/blocks/{slot}`
                .replace(`{${"slot"}}`, encodeURIComponent(String(slot)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (randaoReveal !== undefined) {
                localVarQueryParameter['randao_reveal'] = randaoReveal;
            }

            if (graffiti !== undefined) {
                localVarQueryParameter['graffiti'] = graffiti;
            }

            if (skipRandaoVerification !== undefined) {
                localVarQueryParameter['skip_randao_verification'] = skipRandaoVerification;
            }

            if (builderBoostFactor !== undefined) {
                localVarQueryParameter['builder_boost_factor'] = builderBoostFactor;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests that the beacon node produce a sync committee contribution.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the sync committee contribution refers to a block that has not been fully verified by an execution engine). 
         * @summary Produce a sync committee contribution
         * @param {any} slot The slot for which a sync committee contribution should be created.
         * @param {any} subcommitteeIndex the subcommittee index for which to produce the contribution.
         * @param {any} beaconBlockRoot the block root for which to produce the contribution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        produceSyncCommitteeContribution: async (slot: any, subcommitteeIndex: any, beaconBlockRoot: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slot' is not null or undefined
            if (slot === null || slot === undefined) {
                throw new RequiredError('slot','Required parameter slot was null or undefined when calling produceSyncCommitteeContribution.');
            }
            // verify required parameter 'subcommitteeIndex' is not null or undefined
            if (subcommitteeIndex === null || subcommitteeIndex === undefined) {
                throw new RequiredError('subcommitteeIndex','Required parameter subcommitteeIndex was null or undefined when calling produceSyncCommitteeContribution.');
            }
            // verify required parameter 'beaconBlockRoot' is not null or undefined
            if (beaconBlockRoot === null || beaconBlockRoot === undefined) {
                throw new RequiredError('beaconBlockRoot','Required parameter beaconBlockRoot was null or undefined when calling produceSyncCommitteeContribution.');
            }
            const localVarPath = `/eth/v1/validator/sync_committee_contribution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (slot !== undefined) {
                localVarQueryParameter['slot'] = slot;
            }

            if (subcommitteeIndex !== undefined) {
                localVarQueryParameter['subcommittee_index'] = subcommitteeIndex;
            }

            if (beaconBlockRoot !== undefined) {
                localVarQueryParameter['beacon_block_root'] = beaconBlockRoot;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
         * @summary Publish multiple aggregate and proofs
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishAggregateAndProofs: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling publishAggregateAndProofs.');
            }
            const localVarPath = `/eth/v1/validator/aggregate_and_proofs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish multiple signed sync committee contribution and proofs
         * @summary Publish multiple contribution and proofs
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishContributionAndProofs: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling publishContributionAndProofs.');
            }
            const localVarPath = `/eth/v1/validator/contribution_and_proofs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Prepares the beacon node for engaging with external builders. The information must be sent by the beacon node to the builder network. It is expected that the validator client will send this information periodically to ensure the beacon node has correct and timely registration information to provide to builders. The validator client should not sign blinded beacon blocks that do not adhere to their latest fee recipient and gas limit preferences.  Note that only registrations for active or pending validators must be sent to the builder network. Registrations for unknown or exited validators must be filtered out and not sent to the builder network. 
         * @summary Provide beacon node with registrations for the given validators to the external builder network.
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerValidator: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling registerValidator.');
            }
            const localVarPath = `/eth/v1/validator/register_validator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint should be used by a validator client running as part of a distributed validator cluster, and is  implemented by a distributed validator middleware client. This endpoint is used to exchange partial  selection proofs for combined/aggregated selection proofs to allow a validator client  to correctly determine if any of its validators has been selected to perform an attestation aggregation duty in a slot.  Validator clients running in a distributed validator cluster must query this endpoint at the start of an epoch for the current and lookahead (next) epochs for all validators that have attester duties in the current and lookahead epochs. Consensus clients need not support this endpoint and may return a 501. 
         * @summary Determine if a distributed validator has been selected to aggregate attestations
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitBeaconCommitteeSelections: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling submitBeaconCommitteeSelections.');
            }
            const localVarPath = `/eth/v1/validator/beacon_committee_selections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit sync committee selections to a DVT middleware client. It returns the threshold aggregated sync  committee selection. This endpoint should be used by a validator client running as part of a distributed  validator cluster, and is implemented by a distributed validator middleware client. This endpoint is  used to exchange partial selection proofs (slot signatures) for combined/aggregated selection proofs to  allow a validator client to correctly determine if any of its validators has been selected to perform a  sync committee contribution (sync aggregation) duty in a slot. Validator clients running in a distributed validator cluster must query this endpoint at the start of each slot for all validators that are included in the current sync committee. Consensus clients need not support this endpoint and may return a 501. 
         * @summary Determine if a distributed validator has been selected to make a sync committee contribution
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSyncCommitteeSelections: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling submitSyncCommitteeSelections.');
            }
            const localVarPath = `/eth/v1/validator/sync_committee_selections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValidatorApi - functional programming interface
 * @export
 */
export const ValidatorApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Aggregates all attestations matching given attestation data root and slot.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the aggregated attestation attests to a block that has not been fully verified by an execution engine).  A 404 error must be returned if no attestation is available for the requested `attestation_data_root`. 
         * @summary Get aggregated attestation
         * @param {any} attestationDataRoot HashTreeRoot of AttestationData that validator wants aggregated
         * @param {any} slot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggregatedAttestation(attestationDataRoot: any, slot: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetAggregatedAttestationResponse>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).getAggregatedAttestation(attestationDataRoot, slot, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requests the beacon node to provide a set of attestation duties, which should be performed by validators, for a particular epoch. Duties should only need to be checked once per epoch, however a chain reorganization (of > MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.previous_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) + 1 == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1) - 1)` or the genesis block root in the case of underflow.
         * @summary Get attester duties
         * @param {any} body An array of the validator indices for which to obtain the duties.
         * @param {any} epoch Should only be allowed 1 epoch ahead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttesterDuties(body: any, epoch: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetAttesterDutiesResponse>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).getAttesterDuties(body, epoch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requests the beacon node to indicate if a validator has been observed to be live in a given epoch. The beacon node might detect liveness by observing messages from the validator on the network, in the beacon chain, from its API or from any other source. A beacon node SHOULD support the current and previous epoch, however it MAY support earlier epoch. It is important to note that the values returned by the beacon node are not canonical; they are best-effort and based upon a subjective view of the network. A beacon node that was recently started or suffered a network partition may indicate that a validator is not live when it actually is.
         * @summary Indicates if a validator has been observed on the network
         * @param {any} body An array of the validator indices for which to detect liveness.
         * @param {any} epoch The epoch for which liveness is being queried
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveness(body: any, epoch: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PostLivenessResponseBody>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).getLiveness(body, epoch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1)` or the genesis block root in the case of underflow.
         * @summary Get block proposers duties
         * @param {any} epoch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProposerDuties(epoch: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetProposerDutiesResponse>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).getProposerDuties(epoch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requests the beacon node to provide a set of sync committee duties for a particular epoch.
         * @summary Get sync committee duties
         * @param {any} body An array of the validator indices for which to obtain the duties.
         * @param {any} epoch epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD &lt;&#x3D; current_epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD + 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSyncCommitteeDuties(body: any, epoch: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<GetSyncCommitteeDutiesResponse>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).getSyncCommitteeDuties(body, epoch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * After beacon node receives this request, search using discv5 for peers related to this subnet and replace current peers with those ones if necessary If validator `is_aggregator`, beacon node must: - announce subnet topic subscription on gossipsub - aggregate attestations received on that subnet 
         * @summary Signal beacon node to prepare for a committee subnet
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareBeaconCommitteeSubnet(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).prepareBeaconCommitteeSubnet(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Prepares the beacon node for potential proposers by supplying information required when proposing blocks for the given validators.  The information supplied for each validator index will persist through the epoch in which the call is submitted and for a further two epochs after that, or until the beacon node restarts.  It is expected that validator clients will send this information periodically, for example each epoch, to ensure beacon nodes have correct and timely fee recipient information.  Note that there is no guarantee that the beacon node will use the supplied fee recipient when creating a block proposal, so on receipt of a proposed block the validator should confirm that it finds the fee recipient within the block acceptable before signing it.  Also note that requests containing currently inactive or unknown validator indices will be accepted, as they may become active at a later epoch. 
         * @summary Provide beacon node with proposals for the given validators.
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareBeaconProposer(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).prepareBeaconProposer(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Subscribe to a number of sync committee subnets  Sync committees are not present in phase0, but are required for Altair networks.  Subscribing to sync committee subnets is an action performed by VC to enable network participation in Altair networks, and only required if the VC has an active validator in an active sync committee. 
         * @summary Subscribe to sync committee subnets
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSyncCommitteeSubnets(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).prepareSyncCommitteeSubnets(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requests that the beacon node produce an AttestationData.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the attestation attests to a block that has not been fully verified by an execution engine). 
         * @summary Produce an attestation data
         * @param {any} slot The slot for which an attestation data should be created.
         * @param {any} committeeIndex The committee index for which an attestation data should be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async produceAttestationData(slot: any, committeeIndex: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProduceAttestationDataResponse>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).produceAttestationData(slot, committeeIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requests a beacon node to produce a valid blinded block, which can then be signed by a validator.  A blinded block is a block with only a transactions root, rather than a full transactions list.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.  Before Bellatrix, this endpoint will return a `BeaconBlock`. 
         * @summary Produce a new blinded block, without signature.
         * @param {any} slot The slot for which the block should be proposed.
         * @param {any} randaoReveal The validator&#x27;s randao reveal value.
         * @param {any} [graffiti] Arbitrary data validator wants to include in block.
         * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async produceBlindedBlock(slot: any, randaoReveal: any, graffiti?: any, skipRandaoVerification?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProduceBlindedBlockResponse>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).produceBlindedBlock(slot, randaoReveal, graffiti, skipRandaoVerification, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requests a beacon node to produce a valid block, which can then be signed by a validator.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress. 
         * @summary Produce a new block, without signature.
         * @param {any} slot The slot for which the block should be proposed.
         * @param {any} randaoReveal The validator&#x27;s randao reveal value.
         * @param {any} [graffiti] Arbitrary data validator wants to include in block.
         * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async produceBlockV2(slot: any, randaoReveal: any, graffiti?: any, skipRandaoVerification?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProduceBlockV2Response>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).produceBlockV2(slot, randaoReveal, graffiti, skipRandaoVerification, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requests a beacon node to produce a valid block, which can then be signed by a validator. The returned block may be blinded or unblinded, depending on the current state of the network as decided by the execution and beacon nodes.  The beacon node must return an unblinded block if it obtains the execution payload from its paired execution node. It must only return a blinded block if it obtains the execution payload header from an MEV relay.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress. 
         * @summary Produce a new block, without signature.
         * @param {any} slot The slot for which the block should be proposed.
         * @param {any} randaoReveal The validator&#x27;s randao reveal value.
         * @param {any} [graffiti] Arbitrary data validator wants to include in block.
         * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value. 
         * @param {any} [builderBoostFactor] Percentage multiplier to apply to the builder&#x27;s payload value when choosing between a builder payload header and payload from the paired execution node. This parameter is only relevant if the beacon node is connected to a builder, deems it safe to produce a builder payload, and receives valid responses from both the builder endpoint _and_ the paired execution node. When these preconditions are met, the server MUST act as follows:  * if &#x60;exec_node_payload_value &gt;&#x3D; builder_boost_factor * (builder_payload_value // 100)&#x60;,   then return a full (unblinded) block containing the execution node payload. * otherwise, return a blinded block containing the builder payload header.  Servers must support the following values of the boost factor which encode common preferences:  * &#x60;builder_boost_factor&#x3D;0&#x60;: prefer the execution node payload unless an error makes it   unviable. * &#x60;builder_boost_factor&#x3D;100&#x60;: default profit maximization mode; choose whichever   payload pays more. * &#x60;builder_boost_factor&#x3D;2**64 - 1&#x60;: prefer the builder payload unless an error or   beacon node health check makes it unviable.  Servers should use saturating arithmetic or another technique to ensure that large values of the &#x60;builder_boost_factor&#x60; do not trigger overflows or errors. If this parameter is provided and the beacon node is not configured with a builder then the beacon node MUST respond with a full block, which the caller can choose to reject if it wishes. If this parameter is **not** provided then it should be treated as having the default value of 100. If the value is provided but out of range for a 64-bit unsigned integer, then an error response with status code 400 MUST be returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async produceBlockV3(slot: any, randaoReveal: any, graffiti?: any, skipRandaoVerification?: any, builderBoostFactor?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProduceBlockV3Response>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).produceBlockV3(slot, randaoReveal, graffiti, skipRandaoVerification, builderBoostFactor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requests that the beacon node produce a sync committee contribution.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the sync committee contribution refers to a block that has not been fully verified by an execution engine). 
         * @summary Produce a sync committee contribution
         * @param {any} slot The slot for which a sync committee contribution should be created.
         * @param {any} subcommitteeIndex the subcommittee index for which to produce the contribution.
         * @param {any} beaconBlockRoot the block root for which to produce the contribution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async produceSyncCommitteeContribution(slot: any, subcommitteeIndex: any, beaconBlockRoot: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProduceSyncCommitteeContributionResponse>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).produceSyncCommitteeContribution(slot, subcommitteeIndex, beaconBlockRoot, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
         * @summary Publish multiple aggregate and proofs
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishAggregateAndProofs(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).publishAggregateAndProofs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Publish multiple signed sync committee contribution and proofs
         * @summary Publish multiple contribution and proofs
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishContributionAndProofs(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).publishContributionAndProofs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Prepares the beacon node for engaging with external builders. The information must be sent by the beacon node to the builder network. It is expected that the validator client will send this information periodically to ensure the beacon node has correct and timely registration information to provide to builders. The validator client should not sign blinded beacon blocks that do not adhere to their latest fee recipient and gas limit preferences.  Note that only registrations for active or pending validators must be sent to the builder network. Registrations for unknown or exited validators must be filtered out and not sent to the builder network. 
         * @summary Provide beacon node with registrations for the given validators to the external builder network.
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerValidator(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).registerValidator(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint should be used by a validator client running as part of a distributed validator cluster, and is  implemented by a distributed validator middleware client. This endpoint is used to exchange partial  selection proofs for combined/aggregated selection proofs to allow a validator client  to correctly determine if any of its validators has been selected to perform an attestation aggregation duty in a slot.  Validator clients running in a distributed validator cluster must query this endpoint at the start of an epoch for the current and lookahead (next) epochs for all validators that have attester duties in the current and lookahead epochs. Consensus clients need not support this endpoint and may return a 501. 
         * @summary Determine if a distributed validator has been selected to aggregate attestations
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitBeaconCommitteeSelections(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<BeaconCommitteeSelectionResponse>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).submitBeaconCommitteeSelections(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Submit sync committee selections to a DVT middleware client. It returns the threshold aggregated sync  committee selection. This endpoint should be used by a validator client running as part of a distributed  validator cluster, and is implemented by a distributed validator middleware client. This endpoint is  used to exchange partial selection proofs (slot signatures) for combined/aggregated selection proofs to  allow a validator client to correctly determine if any of its validators has been selected to perform a  sync committee contribution (sync aggregation) duty in a slot. Validator clients running in a distributed validator cluster must query this endpoint at the start of each slot for all validators that are included in the current sync committee. Consensus clients need not support this endpoint and may return a 501. 
         * @summary Determine if a distributed validator has been selected to make a sync committee contribution
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitSyncCommitteeSelections(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<SyncCommitteeSelectionResponse>>> {
            const localVarAxiosArgs = await ValidatorApiAxiosParamCreator(configuration).submitSyncCommitteeSelections(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ValidatorApi - factory interface
 * @export
 */
export const ValidatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Aggregates all attestations matching given attestation data root and slot.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the aggregated attestation attests to a block that has not been fully verified by an execution engine).  A 404 error must be returned if no attestation is available for the requested `attestation_data_root`. 
         * @summary Get aggregated attestation
         * @param {any} attestationDataRoot HashTreeRoot of AttestationData that validator wants aggregated
         * @param {any} slot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggregatedAttestation(attestationDataRoot: any, slot: any, options?: AxiosRequestConfig): Promise<AxiosResponse<GetAggregatedAttestationResponse>> {
            return ValidatorApiFp(configuration).getAggregatedAttestation(attestationDataRoot, slot, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests the beacon node to provide a set of attestation duties, which should be performed by validators, for a particular epoch. Duties should only need to be checked once per epoch, however a chain reorganization (of > MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.previous_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) + 1 == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1) - 1)` or the genesis block root in the case of underflow.
         * @summary Get attester duties
         * @param {any} body An array of the validator indices for which to obtain the duties.
         * @param {any} epoch Should only be allowed 1 epoch ahead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttesterDuties(body: any, epoch: any, options?: AxiosRequestConfig): Promise<AxiosResponse<GetAttesterDutiesResponse>> {
            return ValidatorApiFp(configuration).getAttesterDuties(body, epoch, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests the beacon node to indicate if a validator has been observed to be live in a given epoch. The beacon node might detect liveness by observing messages from the validator on the network, in the beacon chain, from its API or from any other source. A beacon node SHOULD support the current and previous epoch, however it MAY support earlier epoch. It is important to note that the values returned by the beacon node are not canonical; they are best-effort and based upon a subjective view of the network. A beacon node that was recently started or suffered a network partition may indicate that a validator is not live when it actually is.
         * @summary Indicates if a validator has been observed on the network
         * @param {any} body An array of the validator indices for which to detect liveness.
         * @param {any} epoch The epoch for which liveness is being queried
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveness(body: any, epoch: any, options?: AxiosRequestConfig): Promise<AxiosResponse<PostLivenessResponseBody>> {
            return ValidatorApiFp(configuration).getLiveness(body, epoch, options).then((request) => request(axios, basePath));
        },
        /**
         * Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1)` or the genesis block root in the case of underflow.
         * @summary Get block proposers duties
         * @param {any} epoch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProposerDuties(epoch: any, options?: AxiosRequestConfig): Promise<AxiosResponse<GetProposerDutiesResponse>> {
            return ValidatorApiFp(configuration).getProposerDuties(epoch, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests the beacon node to provide a set of sync committee duties for a particular epoch.
         * @summary Get sync committee duties
         * @param {any} body An array of the validator indices for which to obtain the duties.
         * @param {any} epoch epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD &lt;&#x3D; current_epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD + 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSyncCommitteeDuties(body: any, epoch: any, options?: AxiosRequestConfig): Promise<AxiosResponse<GetSyncCommitteeDutiesResponse>> {
            return ValidatorApiFp(configuration).getSyncCommitteeDuties(body, epoch, options).then((request) => request(axios, basePath));
        },
        /**
         * After beacon node receives this request, search using discv5 for peers related to this subnet and replace current peers with those ones if necessary If validator `is_aggregator`, beacon node must: - announce subnet topic subscription on gossipsub - aggregate attestations received on that subnet 
         * @summary Signal beacon node to prepare for a committee subnet
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareBeaconCommitteeSubnet(body: any, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ValidatorApiFp(configuration).prepareBeaconCommitteeSubnet(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Prepares the beacon node for potential proposers by supplying information required when proposing blocks for the given validators.  The information supplied for each validator index will persist through the epoch in which the call is submitted and for a further two epochs after that, or until the beacon node restarts.  It is expected that validator clients will send this information periodically, for example each epoch, to ensure beacon nodes have correct and timely fee recipient information.  Note that there is no guarantee that the beacon node will use the supplied fee recipient when creating a block proposal, so on receipt of a proposed block the validator should confirm that it finds the fee recipient within the block acceptable before signing it.  Also note that requests containing currently inactive or unknown validator indices will be accepted, as they may become active at a later epoch. 
         * @summary Provide beacon node with proposals for the given validators.
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareBeaconProposer(body: any, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ValidatorApiFp(configuration).prepareBeaconProposer(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Subscribe to a number of sync committee subnets  Sync committees are not present in phase0, but are required for Altair networks.  Subscribing to sync committee subnets is an action performed by VC to enable network participation in Altair networks, and only required if the VC has an active validator in an active sync committee. 
         * @summary Subscribe to sync committee subnets
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSyncCommitteeSubnets(body: any, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ValidatorApiFp(configuration).prepareSyncCommitteeSubnets(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests that the beacon node produce an AttestationData.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the attestation attests to a block that has not been fully verified by an execution engine). 
         * @summary Produce an attestation data
         * @param {any} slot The slot for which an attestation data should be created.
         * @param {any} committeeIndex The committee index for which an attestation data should be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async produceAttestationData(slot: any, committeeIndex: any, options?: AxiosRequestConfig): Promise<AxiosResponse<ProduceAttestationDataResponse>> {
            return ValidatorApiFp(configuration).produceAttestationData(slot, committeeIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests a beacon node to produce a valid blinded block, which can then be signed by a validator.  A blinded block is a block with only a transactions root, rather than a full transactions list.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.  Before Bellatrix, this endpoint will return a `BeaconBlock`. 
         * @summary Produce a new blinded block, without signature.
         * @param {any} slot The slot for which the block should be proposed.
         * @param {any} randaoReveal The validator&#x27;s randao reveal value.
         * @param {any} [graffiti] Arbitrary data validator wants to include in block.
         * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async produceBlindedBlock(slot: any, randaoReveal: any, graffiti?: any, skipRandaoVerification?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<ProduceBlindedBlockResponse>> {
            return ValidatorApiFp(configuration).produceBlindedBlock(slot, randaoReveal, graffiti, skipRandaoVerification, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests a beacon node to produce a valid block, which can then be signed by a validator.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress. 
         * @summary Produce a new block, without signature.
         * @param {any} slot The slot for which the block should be proposed.
         * @param {any} randaoReveal The validator&#x27;s randao reveal value.
         * @param {any} [graffiti] Arbitrary data validator wants to include in block.
         * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async produceBlockV2(slot: any, randaoReveal: any, graffiti?: any, skipRandaoVerification?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<ProduceBlockV2Response>> {
            return ValidatorApiFp(configuration).produceBlockV2(slot, randaoReveal, graffiti, skipRandaoVerification, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests a beacon node to produce a valid block, which can then be signed by a validator. The returned block may be blinded or unblinded, depending on the current state of the network as decided by the execution and beacon nodes.  The beacon node must return an unblinded block if it obtains the execution payload from its paired execution node. It must only return a blinded block if it obtains the execution payload header from an MEV relay.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress. 
         * @summary Produce a new block, without signature.
         * @param {any} slot The slot for which the block should be proposed.
         * @param {any} randaoReveal The validator&#x27;s randao reveal value.
         * @param {any} [graffiti] Arbitrary data validator wants to include in block.
         * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value. 
         * @param {any} [builderBoostFactor] Percentage multiplier to apply to the builder&#x27;s payload value when choosing between a builder payload header and payload from the paired execution node. This parameter is only relevant if the beacon node is connected to a builder, deems it safe to produce a builder payload, and receives valid responses from both the builder endpoint _and_ the paired execution node. When these preconditions are met, the server MUST act as follows:  * if &#x60;exec_node_payload_value &gt;&#x3D; builder_boost_factor * (builder_payload_value // 100)&#x60;,   then return a full (unblinded) block containing the execution node payload. * otherwise, return a blinded block containing the builder payload header.  Servers must support the following values of the boost factor which encode common preferences:  * &#x60;builder_boost_factor&#x3D;0&#x60;: prefer the execution node payload unless an error makes it   unviable. * &#x60;builder_boost_factor&#x3D;100&#x60;: default profit maximization mode; choose whichever   payload pays more. * &#x60;builder_boost_factor&#x3D;2**64 - 1&#x60;: prefer the builder payload unless an error or   beacon node health check makes it unviable.  Servers should use saturating arithmetic or another technique to ensure that large values of the &#x60;builder_boost_factor&#x60; do not trigger overflows or errors. If this parameter is provided and the beacon node is not configured with a builder then the beacon node MUST respond with a full block, which the caller can choose to reject if it wishes. If this parameter is **not** provided then it should be treated as having the default value of 100. If the value is provided but out of range for a 64-bit unsigned integer, then an error response with status code 400 MUST be returned. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async produceBlockV3(slot: any, randaoReveal: any, graffiti?: any, skipRandaoVerification?: any, builderBoostFactor?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<ProduceBlockV3Response>> {
            return ValidatorApiFp(configuration).produceBlockV3(slot, randaoReveal, graffiti, skipRandaoVerification, builderBoostFactor, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests that the beacon node produce a sync committee contribution.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the sync committee contribution refers to a block that has not been fully verified by an execution engine). 
         * @summary Produce a sync committee contribution
         * @param {any} slot The slot for which a sync committee contribution should be created.
         * @param {any} subcommitteeIndex the subcommittee index for which to produce the contribution.
         * @param {any} beaconBlockRoot the block root for which to produce the contribution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async produceSyncCommitteeContribution(slot: any, subcommitteeIndex: any, beaconBlockRoot: any, options?: AxiosRequestConfig): Promise<AxiosResponse<ProduceSyncCommitteeContributionResponse>> {
            return ValidatorApiFp(configuration).produceSyncCommitteeContribution(slot, subcommitteeIndex, beaconBlockRoot, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
         * @summary Publish multiple aggregate and proofs
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishAggregateAndProofs(body: any, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ValidatorApiFp(configuration).publishAggregateAndProofs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish multiple signed sync committee contribution and proofs
         * @summary Publish multiple contribution and proofs
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishContributionAndProofs(body: any, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ValidatorApiFp(configuration).publishContributionAndProofs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Prepares the beacon node for engaging with external builders. The information must be sent by the beacon node to the builder network. It is expected that the validator client will send this information periodically to ensure the beacon node has correct and timely registration information to provide to builders. The validator client should not sign blinded beacon blocks that do not adhere to their latest fee recipient and gas limit preferences.  Note that only registrations for active or pending validators must be sent to the builder network. Registrations for unknown or exited validators must be filtered out and not sent to the builder network. 
         * @summary Provide beacon node with registrations for the given validators to the external builder network.
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerValidator(body: any, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ValidatorApiFp(configuration).registerValidator(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint should be used by a validator client running as part of a distributed validator cluster, and is  implemented by a distributed validator middleware client. This endpoint is used to exchange partial  selection proofs for combined/aggregated selection proofs to allow a validator client  to correctly determine if any of its validators has been selected to perform an attestation aggregation duty in a slot.  Validator clients running in a distributed validator cluster must query this endpoint at the start of an epoch for the current and lookahead (next) epochs for all validators that have attester duties in the current and lookahead epochs. Consensus clients need not support this endpoint and may return a 501. 
         * @summary Determine if a distributed validator has been selected to aggregate attestations
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitBeaconCommitteeSelections(body: any, options?: AxiosRequestConfig): Promise<AxiosResponse<BeaconCommitteeSelectionResponse>> {
            return ValidatorApiFp(configuration).submitBeaconCommitteeSelections(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit sync committee selections to a DVT middleware client. It returns the threshold aggregated sync  committee selection. This endpoint should be used by a validator client running as part of a distributed  validator cluster, and is implemented by a distributed validator middleware client. This endpoint is  used to exchange partial selection proofs (slot signatures) for combined/aggregated selection proofs to  allow a validator client to correctly determine if any of its validators has been selected to perform a  sync committee contribution (sync aggregation) duty in a slot. Validator clients running in a distributed validator cluster must query this endpoint at the start of each slot for all validators that are included in the current sync committee. Consensus clients need not support this endpoint and may return a 501. 
         * @summary Determine if a distributed validator has been selected to make a sync committee contribution
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitSyncCommitteeSelections(body: any, options?: AxiosRequestConfig): Promise<AxiosResponse<SyncCommitteeSelectionResponse>> {
            return ValidatorApiFp(configuration).submitSyncCommitteeSelections(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValidatorApi - object-oriented interface
 * @export
 * @class ValidatorApi
 * @extends {BaseAPI}
 */
export class ValidatorApi extends BaseAPI {
    /**
     * Aggregates all attestations matching given attestation data root and slot.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the aggregated attestation attests to a block that has not been fully verified by an execution engine).  A 404 error must be returned if no attestation is available for the requested `attestation_data_root`. 
     * @summary Get aggregated attestation
     * @param {any} attestationDataRoot HashTreeRoot of AttestationData that validator wants aggregated
     * @param {any} slot 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async getAggregatedAttestation(attestationDataRoot: any, slot: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetAggregatedAttestationResponse>> {
        return ValidatorApiFp(this.configuration).getAggregatedAttestation(attestationDataRoot, slot, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests the beacon node to provide a set of attestation duties, which should be performed by validators, for a particular epoch. Duties should only need to be checked once per epoch, however a chain reorganization (of > MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.previous_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) + 1 == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1) - 1)` or the genesis block root in the case of underflow.
     * @summary Get attester duties
     * @param {any} body An array of the validator indices for which to obtain the duties.
     * @param {any} epoch Should only be allowed 1 epoch ahead
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async getAttesterDuties(body: any, epoch: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetAttesterDutiesResponse>> {
        return ValidatorApiFp(this.configuration).getAttesterDuties(body, epoch, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests the beacon node to indicate if a validator has been observed to be live in a given epoch. The beacon node might detect liveness by observing messages from the validator on the network, in the beacon chain, from its API or from any other source. A beacon node SHOULD support the current and previous epoch, however it MAY support earlier epoch. It is important to note that the values returned by the beacon node are not canonical; they are best-effort and based upon a subjective view of the network. A beacon node that was recently started or suffered a network partition may indicate that a validator is not live when it actually is.
     * @summary Indicates if a validator has been observed on the network
     * @param {any} body An array of the validator indices for which to detect liveness.
     * @param {any} epoch The epoch for which liveness is being queried
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async getLiveness(body: any, epoch: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<PostLivenessResponseBody>> {
        return ValidatorApiFp(this.configuration).getLiveness(body, epoch, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch` - event.block otherwise  The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1)` or the genesis block root in the case of underflow.
     * @summary Get block proposers duties
     * @param {any} epoch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async getProposerDuties(epoch: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetProposerDutiesResponse>> {
        return ValidatorApiFp(this.configuration).getProposerDuties(epoch, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests the beacon node to provide a set of sync committee duties for a particular epoch.
     * @summary Get sync committee duties
     * @param {any} body An array of the validator indices for which to obtain the duties.
     * @param {any} epoch epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD &lt;&#x3D; current_epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD + 1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async getSyncCommitteeDuties(body: any, epoch: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<GetSyncCommitteeDutiesResponse>> {
        return ValidatorApiFp(this.configuration).getSyncCommitteeDuties(body, epoch, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * After beacon node receives this request, search using discv5 for peers related to this subnet and replace current peers with those ones if necessary If validator `is_aggregator`, beacon node must: - announce subnet topic subscription on gossipsub - aggregate attestations received on that subnet 
     * @summary Signal beacon node to prepare for a committee subnet
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async prepareBeaconCommitteeSubnet(body: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ValidatorApiFp(this.configuration).prepareBeaconCommitteeSubnet(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Prepares the beacon node for potential proposers by supplying information required when proposing blocks for the given validators.  The information supplied for each validator index will persist through the epoch in which the call is submitted and for a further two epochs after that, or until the beacon node restarts.  It is expected that validator clients will send this information periodically, for example each epoch, to ensure beacon nodes have correct and timely fee recipient information.  Note that there is no guarantee that the beacon node will use the supplied fee recipient when creating a block proposal, so on receipt of a proposed block the validator should confirm that it finds the fee recipient within the block acceptable before signing it.  Also note that requests containing currently inactive or unknown validator indices will be accepted, as they may become active at a later epoch. 
     * @summary Provide beacon node with proposals for the given validators.
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async prepareBeaconProposer(body: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ValidatorApiFp(this.configuration).prepareBeaconProposer(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Subscribe to a number of sync committee subnets  Sync committees are not present in phase0, but are required for Altair networks.  Subscribing to sync committee subnets is an action performed by VC to enable network participation in Altair networks, and only required if the VC has an active validator in an active sync committee. 
     * @summary Subscribe to sync committee subnets
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async prepareSyncCommitteeSubnets(body: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ValidatorApiFp(this.configuration).prepareSyncCommitteeSubnets(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests that the beacon node produce an AttestationData.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the attestation attests to a block that has not been fully verified by an execution engine). 
     * @summary Produce an attestation data
     * @param {any} slot The slot for which an attestation data should be created.
     * @param {any} committeeIndex The committee index for which an attestation data should be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async produceAttestationData(slot: any, committeeIndex: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProduceAttestationDataResponse>> {
        return ValidatorApiFp(this.configuration).produceAttestationData(slot, committeeIndex, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests a beacon node to produce a valid blinded block, which can then be signed by a validator.  A blinded block is a block with only a transactions root, rather than a full transactions list.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress.  Before Bellatrix, this endpoint will return a `BeaconBlock`. 
     * @summary Produce a new blinded block, without signature.
     * @param {any} slot The slot for which the block should be proposed.
     * @param {any} randaoReveal The validator&#x27;s randao reveal value.
     * @param {any} [graffiti] Arbitrary data validator wants to include in block.
     * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async produceBlindedBlock(slot: any, randaoReveal: any, graffiti?: any, skipRandaoVerification?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProduceBlindedBlockResponse>> {
        return ValidatorApiFp(this.configuration).produceBlindedBlock(slot, randaoReveal, graffiti, skipRandaoVerification, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests a beacon node to produce a valid block, which can then be signed by a validator.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress. 
     * @summary Produce a new block, without signature.
     * @param {any} slot The slot for which the block should be proposed.
     * @param {any} randaoReveal The validator&#x27;s randao reveal value.
     * @param {any} [graffiti] Arbitrary data validator wants to include in block.
     * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async produceBlockV2(slot: any, randaoReveal: any, graffiti?: any, skipRandaoVerification?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProduceBlockV2Response>> {
        return ValidatorApiFp(this.configuration).produceBlockV2(slot, randaoReveal, graffiti, skipRandaoVerification, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests a beacon node to produce a valid block, which can then be signed by a validator. The returned block may be blinded or unblinded, depending on the current state of the network as decided by the execution and beacon nodes.  The beacon node must return an unblinded block if it obtains the execution payload from its paired execution node. It must only return a blinded block if it obtains the execution payload header from an MEV relay.  Metadata in the response indicates the type of block produced, and the supported types of block will be added to as forks progress. 
     * @summary Produce a new block, without signature.
     * @param {any} slot The slot for which the block should be proposed.
     * @param {any} randaoReveal The validator&#x27;s randao reveal value.
     * @param {any} [graffiti] Arbitrary data validator wants to include in block.
     * @param {any} [skipRandaoVerification] Skip verification of the &#x60;randao_reveal&#x60; value. If this flag is set then the &#x60;randao_reveal&#x60; must be set to the point at infinity (&#x60;0xc0..00&#x60;). This query parameter is a flag and does not take a value. 
     * @param {any} [builderBoostFactor] Percentage multiplier to apply to the builder&#x27;s payload value when choosing between a builder payload header and payload from the paired execution node. This parameter is only relevant if the beacon node is connected to a builder, deems it safe to produce a builder payload, and receives valid responses from both the builder endpoint _and_ the paired execution node. When these preconditions are met, the server MUST act as follows:  * if &#x60;exec_node_payload_value &gt;&#x3D; builder_boost_factor * (builder_payload_value // 100)&#x60;,   then return a full (unblinded) block containing the execution node payload. * otherwise, return a blinded block containing the builder payload header.  Servers must support the following values of the boost factor which encode common preferences:  * &#x60;builder_boost_factor&#x3D;0&#x60;: prefer the execution node payload unless an error makes it   unviable. * &#x60;builder_boost_factor&#x3D;100&#x60;: default profit maximization mode; choose whichever   payload pays more. * &#x60;builder_boost_factor&#x3D;2**64 - 1&#x60;: prefer the builder payload unless an error or   beacon node health check makes it unviable.  Servers should use saturating arithmetic or another technique to ensure that large values of the &#x60;builder_boost_factor&#x60; do not trigger overflows or errors. If this parameter is provided and the beacon node is not configured with a builder then the beacon node MUST respond with a full block, which the caller can choose to reject if it wishes. If this parameter is **not** provided then it should be treated as having the default value of 100. If the value is provided but out of range for a 64-bit unsigned integer, then an error response with status code 400 MUST be returned. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async produceBlockV3(slot: any, randaoReveal: any, graffiti?: any, skipRandaoVerification?: any, builderBoostFactor?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProduceBlockV3Response>> {
        return ValidatorApiFp(this.configuration).produceBlockV3(slot, randaoReveal, graffiti, skipRandaoVerification, builderBoostFactor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests that the beacon node produce a sync committee contribution.  A 503 error must be returned if the block identified by the response `beacon_block_root` is optimistic (i.e. the sync committee contribution refers to a block that has not been fully verified by an execution engine). 
     * @summary Produce a sync committee contribution
     * @param {any} slot The slot for which a sync committee contribution should be created.
     * @param {any} subcommitteeIndex the subcommittee index for which to produce the contribution.
     * @param {any} beaconBlockRoot the block root for which to produce the contribution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async produceSyncCommitteeContribution(slot: any, subcommitteeIndex: any, beaconBlockRoot: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProduceSyncCommitteeContributionResponse>> {
        return ValidatorApiFp(this.configuration).produceSyncCommitteeContribution(slot, subcommitteeIndex, beaconBlockRoot, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
     * @summary Publish multiple aggregate and proofs
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async publishAggregateAndProofs(body: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ValidatorApiFp(this.configuration).publishAggregateAndProofs(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Publish multiple signed sync committee contribution and proofs
     * @summary Publish multiple contribution and proofs
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async publishContributionAndProofs(body: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ValidatorApiFp(this.configuration).publishContributionAndProofs(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Prepares the beacon node for engaging with external builders. The information must be sent by the beacon node to the builder network. It is expected that the validator client will send this information periodically to ensure the beacon node has correct and timely registration information to provide to builders. The validator client should not sign blinded beacon blocks that do not adhere to their latest fee recipient and gas limit preferences.  Note that only registrations for active or pending validators must be sent to the builder network. Registrations for unknown or exited validators must be filtered out and not sent to the builder network. 
     * @summary Provide beacon node with registrations for the given validators to the external builder network.
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async registerValidator(body: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ValidatorApiFp(this.configuration).registerValidator(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint should be used by a validator client running as part of a distributed validator cluster, and is  implemented by a distributed validator middleware client. This endpoint is used to exchange partial  selection proofs for combined/aggregated selection proofs to allow a validator client  to correctly determine if any of its validators has been selected to perform an attestation aggregation duty in a slot.  Validator clients running in a distributed validator cluster must query this endpoint at the start of an epoch for the current and lookahead (next) epochs for all validators that have attester duties in the current and lookahead epochs. Consensus clients need not support this endpoint and may return a 501. 
     * @summary Determine if a distributed validator has been selected to aggregate attestations
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async submitBeaconCommitteeSelections(body: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<BeaconCommitteeSelectionResponse>> {
        return ValidatorApiFp(this.configuration).submitBeaconCommitteeSelections(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submit sync committee selections to a DVT middleware client. It returns the threshold aggregated sync  committee selection. This endpoint should be used by a validator client running as part of a distributed  validator cluster, and is implemented by a distributed validator middleware client. This endpoint is  used to exchange partial selection proofs (slot signatures) for combined/aggregated selection proofs to  allow a validator client to correctly determine if any of its validators has been selected to perform a  sync committee contribution (sync aggregation) duty in a slot. Validator clients running in a distributed validator cluster must query this endpoint at the start of each slot for all validators that are included in the current sync committee. Consensus clients need not support this endpoint and may return a 501. 
     * @summary Determine if a distributed validator has been selected to make a sync committee contribution
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public async submitSyncCommitteeSelections(body: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<SyncCommitteeSelectionResponse>> {
        return ValidatorApiFp(this.configuration).submitSyncCommitteeSelections(body, options).then((request) => request(this.axios, this.basePath));
    }
}
